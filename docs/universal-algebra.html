<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><meta charset="utf-8"><link href="https://www.howion.com/favicon.svg" rel="icon" type="image/svg+xml"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><title>Universal Algebra</title><style>html{color:#1a1a1a;background-color:#fdfdfd}body{margin:0 auto;max-width:36em;padding-left:50px;padding-right:50px;padding-top:50px;padding-bottom:50px;hyphens:auto;overflow-wrap:break-word;text-rendering:optimizeLegibility;font-kerning:normal}@media (max-width:600px){body{font-size:.9em;padding:12px}h1{font-size:1.8em}}@media print{html{background-color:#fff}body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}p{margin:1em 0}a{color:#1a1a1a}a:visited{color:#1a1a1a}img{max-width:100%}svg{height:auto;max-width:100%}h1,h2,h3,h4,h5,h6{margin-top:1.4em}h5,h6{font-size:1em;font-style:italic}h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-family:Menlo,Monaco,Consolas,'Lucida Console',monospace;font-size:85%;margin:0;hyphens:manual}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible;overflow-wrap:normal}.sourceCode{background-color:transparent;overflow:visible}hr{border:none;border-top:1px solid #1a1a1a;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}header{margin-bottom:4em;text-align:center}#TOC li{list-style:none}#TOC ul{padding-left:1.3em}#TOC>ul{padding-left:0}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}div.columns{display:flex;gap:min(4vw,1.5em)}div.column{flex:auto;overflow-x:auto}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list[class]{list-style:none}ul.task-list li input[type=checkbox]{font-size:inherit;width:.8em;margin:0 .8em .2em -1.6em;vertical-align:middle}</style><style>@import url(https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap);html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility}svg{shape-rendering:geometricPrecision;text-rendering:geometricPrecision}a,h1,h2,h3,h4,h5,h6,img,p{box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:inherit;-moz-osx-font-smoothing:inherit;backface-visibility:hidden;transform:translateZ(0);user-drag:none}img{display:block;max-width:100%;image-rendering:crisp-edges;image-rendering:pixelated;-webkit-touch-callout:none;-webkit-user-drag:none;user-select:none}*{border-collapse:inherit}*,:after,:before{box-sizing:inherit}svg{display:inline-block;fill:currentColor}a,button{-webkit-tap-highlight-color:transparent}:where(code,kbd,samp,pre){font-size:1em}canvas,picture,svg,video{max-width:100%;display:block}:where(article,aside,details,figcaption,figure,footer,header,main,menu,nav,section){display:block}a{text-decoration:none}a:hover{text-decoration:underline}html{margin:0;padding:0;padding-bottom:4em}body{padding:0 24px;margin:0 auto;max-width:912px;font-size:16px;font-family:Inter,sans-serif;font-optical-sizing:auto;font-weight:400;font-style:normal;line-height:1.5}blockquote{background-color:rgba(0,0,0,.05);border-left:.25em solid rgba(0,0,0,.05);padding:.25em .25em .25em 1em;margin:0 0 1em 0}h1{font-size:4em;margin-top:1em;line-height:1.25}h2{border-bottom:2px solid #000;padding-bottom:.25em;margin-top:1.5em}h1{break-before:page}h2,h3,h4,h5,h6{break-before:auto}</style><style id="page_style">@page{margin:0;padding:.25in .325in;size:10in 13in}</style><script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){for(var e=document.getElementsByClassName("math"),t=[],a=0;a<e.length;a++){var n=e[a].firstChild;"SPAN"==e[a].tagName&&katex.render(n.data,e[a],{displayMode:e[a].classList.contains("display"),throwOnError:!1,macros:t,fleqn:!1})}})</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><h1>Table of Contents</h1><nav role="doc-toc"><ul><li><a href="#universal-algebra" id="toc-universal-algebra">Universal Algebra</a><ul><li><a href="#preliminaries" id="toc-preliminaries">Preliminaries</a><li><a href="#notation" id="toc-notation">Notation</a></ul><li><a href="#ordered-sets" id="toc-ordered-sets">Ordered Sets</a><ul><li><a href="#def.-partial-order" id="toc-def.-partial-order">Def. Partial Order</a><li><a href="#def.-chains" id="toc-def.-chains">Def. Chains</a><li><a href="#notation-1" id="toc-notation-1">Notation</a><li><a href="#def.-maps-on-orders" id="toc-def.-maps-on-orders">Def. Maps on Orders</a><li><a href="#example.-social-choice-function" id="toc-example.-social-choice-function">Example. Social Choice Function</a><li><a href="#def.-cover-relation" id="toc-def.-cover-relation">Def. Cover Relation</a><li><a href="#def.-hasse-diagrams" id="toc-def.-hasse-diagrams">Def. Hasse Diagrams</a><li><a href="#thm.-tfae" id="toc-thm.-tfae">Thm. TFAE</a><li><a href="#def.-dual" id="toc-def.-dual">Def. Dual</a><li><a href="#def.-bottom-and-top" id="toc-def.-bottom-and-top">Def. Bottom and Top</a><li><a href="#def.-min-maximal" id="toc-def.-min-maximal">Def. Min-Max(imal)</a><li><a href="#def.-sums" id="toc-def.-sums">Def. Sums</a><li><a href="#def.-linear-sum" id="toc-def.-linear-sum">Def. Linear Sum</a><li><a href="#def.-product" id="toc-def.-product">Def. Product</a><li><a href="#example." id="toc-example.">Example. ’</a><li><a href="#def.-ups-and-downs" id="toc-def.-ups-and-downs">Def. Ups and Downs</a><li><a href="#def.-ordered-set-of-down-sets" id="toc-def.-ordered-set-of-down-sets">Def. Ordered Set of Down-sets</a><li><a href="#thm." id="toc-thm.">Thm. ’</a></ul><li><a href="#lattices" id="toc-lattices">Lattices</a><ul><li><a href="#def.-bounds" id="toc-def.-bounds">Def. Bounds</a><li><a href="#notation.-join-and-meet" id="toc-notation.-join-and-meet">Notation. Join and Meet</a><li><a href="#def.-lattice-and-complete-lattice" id="toc-def.-lattice-and-complete-lattice">Def. Lattice and Complete Lattice</a><li><a href="#def.-axiomatic-definition" id="toc-def.-axiomatic-definition">Def. Axiomatic Definition</a></ul></ul></nav><h1 id="universal-algebra">Universal Algebra</h1><ul><li><strong>Introduction to Lattices and Order</strong>, 2nd Ed. by B.A. Davey and H.A. Priestley.<li><strong>A Course in Universal Algebra</strong>, Millenium Ed. by Stanley Burris and H.P. Sankappanavar.</ul><h2 id="preliminaries">Preliminaries</h2><p>Fundamental set-theoric notation.<h2 id="notation">Notation</h2><ul><li><span class="math inline">x \nleqslant y</span> means “not <span class="math inline">x \leqslant y</span>”.<li><span class="math inline">\phi : P \to Q</span> denotes a map (function) <span class="math inline">\phi</span> from <span class="math inline">P</span> to <span class="math inline">Q</span>.<li><span class="math inline">\phi : P \hookrightarrow Q</span> denotes the <em>injective (one-to-one)</em> map <span class="math inline">\phi</span> from <span class="math inline">P</span> <em>into</em> <span class="math inline">Q</span>.<li><span class="math inline">\phi : P \twoheadrightarrow Q</span> denotes the <em>surjective</em> map <span class="math inline">\phi</span> from <span class="math inline">P</span> <em>onto</em> <span class="math inline">Q</span>.<li><span class="math inline">\phi : P \xrightarrow{\thicksim} Q</span> denotes the <em>bijective</em> map <span class="math inline">\phi</span> from <span class="math inline">P</span> <em>into</em> and <em>onto</em> <span class="math inline">Q</span>.<li><span class="math inline">P \multimap\negthinspace\to Q</span> denotes the <em>set of all partial maps</em> from <span class="math inline">P</span> to <span class="math inline">Q</span>.</ul><h1 id="ordered-sets">Ordered Sets</h1><h2 id="def.-partial-order">Def. Partial Order</h2><p>A <strong>partial order</strong> (relation) or simply an <strong>order</strong> (relation) on some set <span class="math inline">P</span> is a binary relation <span class="math inline">\leqslant</span> on <span class="math inline">P</span> such that, for all <span class="math inline">x,y,z \in P</span>, it is<ol type="1"><li><strong>Reflexive:</strong> <span class="math inline">x \leqslant x</span>.<li><strong>Antisymmetric:</strong> <span class="math inline">x \leqslant y</span> and <span class="math inline">y \leqslant x</span> implies <span class="math inline">x=y</span>.<li><strong>Transitive:</strong> <span class="math inline">x \leqslant y</span> and <span class="math inline">y \leqslant z</span> implies <span class="math inline">x \leqslant z</span>.</ol><p>We say <span class="math inline">x</span> and <span class="math inline">y</span> are <strong>comparable</strong> if either <span class="math inline">x \leqslant y</span> or <span class="math inline">y \leqslant x</span>.<p>The set <span class="math inline">P</span> with such order relation <span class="math inline">\leqslant</span> is said to be a (partially) <strong>ordered set</strong>, or simply a <strong>poset</strong> denoted <span class="math inline">\langle P; \leqslant \rangle</span>.<p>On any set, <span class="math inline">=</span> is an order called the <strong>discrete order</strong>.<p>A binary relation <span class="math inline">\leqslant</span> that satisfies (1) and (3) but not necessarily (3) is called a <strong>quasi-order</strong> or <strong>pre-order</strong>.<p>Let <span class="math inline">\langle P; \leqslant_P \rangle</span> and <span class="math inline">Q \subseteq P</span>. Then <span class="math inline">Q</span> inherits an order relation <span class="math inline">\leqslant_Q</span> from <span class="math inline">P</span> such that for all <span class="math inline">x,y \in Q</span> we have <span class="math inline">x \leqslant_Q y \iff x \leqslant_P y</span> called the <strong>induced order</strong> or the <strong>order inherited from <span class="math inline">P</span></strong>.<h2 id="def.-chains">Def. Chains</h2><p>Let <span class="math inline">\langle P; \leqslant\rangle</span> be a poset. Then <span class="math inline">P</span> is said to be a <strong>chain</strong> (or <strong>linearly ordered set</strong> or <strong>totally ordered set</strong>) if any two elements of <span class="math inline">P</span> are comparable.<p>Similarly, <span class="math inline">P</span> is said to be an <strong>antichain</strong> if, for all <span class="math inline">x,y \in P</span>, we have <span class="math inline">x \leqslant y</span> implies <span class="math inline">x=y</span>.<p>Notice that any subset of a chain (an antichain) is a chain (an antichain).<h2 id="notation-1">Notation</h2><p>We will utilize the symbol <span class="math inline">\bold{n}</span> to denote the finite <span class="math inline">n</span>-element linearly ordered set <span class="math inline">\{0, 1, ..., n-1\}</span> with the natural linear order. Similarly, <span class="math inline">\bold{\bar{n}}</span> will denote the <span class="math inline">n</span>-element antichain.<h2 id="def.-maps-on-orders">Def. Maps on Orders</h2><p>Let <span class="math inline">P</span> and <span class="math inline">Q</span> be two ordered sets. We say a map <span class="math inline">\phi: P \to Q</span> is:<ul><li><strong>order-preserving</strong> if <span class="math inline">x \leqslant_P y</span> implies <span class="math inline">\phi(x) \leqslant_Q \phi(y)</span>.<li><strong>order-embedding</strong> if it is order-preserving and <span class="math inline">\phi(x) \leqslant_Q \phi(y)</span> implies <span class="math inline">x \leqslant_P y</span>.<li><strong>order-isomorphism</strong> if it is order-embedding and <span class="math inline">\phi</span> is surjective.</ul><p>Notice that:<ul><li>Order-embeddings are injective. Therefore, order-isomorphisms are bijective.<li>Not every bijective map between <span class="math inline">P</span> and <span class="math inline">Q</span> is an order-isomorphism.<li>Finite composition of order-preserving maps is again order-preserving.</ul><!--

    ## Def. Order-Isomorphism

    We say two ordered sets $P$ and $Q$ are (order-)**isomorphic** denoted $P \cong Q$ if there exists a surjective map (function) $\phi: P \twoheadrightarrow Q$ such that, for all $x,y \in P$:

    $$
    x \leqslant_P y \iff
    \phi(x) \leqslant_Q \phi(y)
    $$

    Such a map $\phi$ is called an **order-isomorphism**.

    Notice that:

    * $\phi$ must also be injective and thus bijective.
    * Not every bijective map between $P$ and $Q$ is an order-isomorphism. --><h2 id="example.-social-choice-function">Example. Social Choice Function</h2><p>See <a href="https://en.wikipedia.org/wiki/Arrow%27s_impossibility_theorem"><strong>Wikipedia</strong>: Arrow’s impossibility theorem</a>.<h2 id="def.-cover-relation">Def. Cover Relation</h2><blockquote><p>TODO: Check if this definition is equivalent to the one in the main book.</blockquote><p>Let <span class="math inline">P</span> be an ordered set and <span class="math inline">x, y \in P</span>. We say <span class="math inline">x</span> is <strong>covered by</strong> <span class="math inline">y</span> denoted with <span class="math inline">x \prec y</span> if <span class="math inline">x \neq y</span> and there is no <span class="math inline">z \in P</span> distinct from <span class="math inline">x</span> and <span class="math inline">y</span> such that<p><span class="math display">x \leqslant z \leqslant y</span><h2 id="def.-hasse-diagrams">Def. Hasse Diagrams</h2><p>See <a href="https://en.wikipedia.org/wiki/Hasse_diagram"><strong>Wikipedia:</strong> Hasse Diagram</a>.<h2 id="thm.-tfae">Thm. TFAE</h2><p>Let <span class="math inline">P</span> and <span class="math inline">Q</span> be finite ordered sets and <span class="math inline">\phi : P \to Q</span> a bijective map. Then TFAE:<ul><li><span class="math inline">\phi</span> is an order-isomorphism<li><span class="math inline">x \lt_P y</span> if and only if <span class="math inline">\phi(x) \lt_Q \phi(y)</span>.<li><span class="math inline">x \prec_P y</span> if and only if <span class="math inline">\phi(x) \prec_Q \phi(y)</span>.<li>They can be drawn with identical Hasse Diagrams.</ul><h2 id="def.-dual">Def. Dual</h2><p>Let <span class="math inline">P</span> be an ordered set with the order relation <span class="math inline">\leqslant</span>. The <strong>dual</strong> of <span class="math inline">P</span> denoted with <span class="math inline">P^\partial</span> is the set ordered with <span class="math inline">\leqslant_\partial</span> where, for all <span class="math inline">x, y \in P</span>:<p><span class="math display">x \leqslant_\partial y \iff y \leqslant x</span></p><!-- ## Thm. Duality Principle

    Given a statement $\Phi$ about ordered sets which is true in all ordered sets, the dual statement $\Phi^\partial$ is also true in all ordered sets. --><h2 id="def.-bottom-and-top">Def. Bottom and Top</h2><p>For an ordered set <span class="math inline">P</span>, we say <span class="math inline">P</span> has a <strong>bottom</strong> <span class="math inline">\bot \in P</span> if for all <span class="math inline">x \in P</span> we have <span class="math inline">\bot \leqslant x</span>. Similarly, we say <span class="math inline">P</span> has a <strong>top</strong> <span class="math inline">\top \in P</span> if for all <span class="math inline">x \in P</span> we have <span class="math inline">x \leqslant \top</span>.<p>Notice that <span class="math inline">\top</span> and <span class="math inline">\bot</span> are unique when they exist due to antisymmetry, and they are comparable with any element.<p>For example, for <span class="math inline">\langle \mathcal{P}(X); \subseteq\rangle</span>, we have <span class="math inline">\bot = \varnothing</span> and <span class="math inline">\top = X</span>.<p>A finite chain always has bottom and top element.</p><!-- ## Lifts --><h2 id="def.-min-maximal">Def. Min-Max(imal)</h2><p>Let <span class="math inline">P</span> be an ordered set and <span class="math inline">p \in P</span>. We say <span class="math inline">a \in P</span> is:<ul><li><strong>maximal element of <span class="math inline">P</span></strong> if <span class="math inline">a \leqslant x \implies a = x</span>. We denote the <strong>set of maximal elements</strong> with <span class="math inline">\text{Max}\ P</span>.<li><strong>minimal element of <span class="math inline">P</span></strong> if <span class="math inline">x \leqslant a \implies a =x</span>. Similarly, we denote <strong>the set of minimal elements</strong> with <span class="math inline">\text{Min}\ P</span>.<li><strong>maximum</strong> (or <strong>greatest</strong>) if <span class="math inline">a</span> is the (unique) top element.<li><strong>minimum</strong> (or <strong>least</strong>) if <span class="math inline">a</span> is the (unique) bottom element.</ul><p>Notice that if <span class="math inline">P</span> has a top element <span class="math inline">\top</span>, then <span class="math inline">\text{Max}\ P = \{\top\}</span>.<h2 id="def.-sums">Def. Sums</h2><p>Suppose <span class="math inline">P</span> and <span class="math inline">Q</span> are two disjoint ordered sets. The <strong>disjoint union</strong> denoted <span class="math inline">P \sqcup Q</span> is the ordered set <span class="math inline">P \cup Q</span> ordered by <span class="math inline">\leqslant</span> where <span class="math inline">x \leqslant y</span> if and only if either:<ul><li>For <span class="math inline">x,y \in P</span> we have <span class="math inline">x \leqslant_P y</span>,<li>For <span class="math inline">x,y \in Q</span> we have <span class="math inline">x \leqslant_Q y</span>.</ul><h2 id="def.-linear-sum">Def. Linear Sum</h2><p>For two disjoint ordered sets <span class="math inline">P</span> and <span class="math inline">Q</span>, the <strong>linear sum</strong> denoted <span class="math inline">P \oplus Q</span> is the ordered set <span class="math inline">P \cup Q</span> ordered by <span class="math inline">\leqslant</span> where <span class="math inline">x \leqslant y</span> if and only if either:<ul><li>For <span class="math inline">x,y \in P</span> we have <span class="math inline">x \leqslant_P y</span>,<li>For <span class="math inline">x,y \in Q</span> we have <span class="math inline">x \leqslant_Q y</span>.<li><span class="math inline">x \in \text{Max}\ P</span> and <span class="math inline">y \in \text{Min}\ Q</span>.</ul><p>Obviously, <span class="math inline">\oplus</span> is not necessarily commutative.<p>Note that both <span class="math inline">\sqcup</span> and <span class="math inline">\oplus</span> are associative (up to isomorphism).<p>For example, <span class="math inline">\bold{2} \oplus \bold {3} = \bold{5}</span>.<h2 id="def.-product">Def. Product</h2><p>Let <span class="math inline">P_1, ..., P_n</span> be ordered sets. The (Cartesian) product <span class="math inline">P_1 \times ... \times P_n</span> can be (coordinatewise) ordered with <span class="math inline">\leqslant</span> where <span class="math inline">(x_1, ..., x_n) \leqslant (y_1, ..., y_n)</span> if and only if, for all <span class="math inline">i</span>, we have <span class="math inline">x_i \leqslant_{P_i} y_i</span>. As a shorthand we will use <span class="math inline">P^n</span> to denote the <span class="math inline">n</span>-fold cartesian product ordered with such order.<h2 id="example.">Example. ’</h2><p>Let <span class="math inline">X = \{1, 2, ..., n\}</span> and <span class="math inline">\phi : \mathcal{P}(X) \to \bold{2}^n</span> such that <span class="math inline">\phi(A) = (\varepsilon_1, ..., \varepsilon_n)</span> where<p><span class="math display">\varepsilon_i = \begin{cases} \ 1 &amp;\text{if } \enspace i \in A \\ \ 0 &amp;\text{if } \enspace i \notin A \end{cases}</span><p>Then <span class="math inline">\phi</span> is an order-isomorphism.<h2 id="def.-ups-and-downs">Def. Ups and Downs</h2><p>Let <span class="math inline">P</span> be an ordered set and <span class="math inline">Q \subseteq P</span>.<p>Then, we say <span class="math inline">Q</span> is a <strong>down-set</strong> (or <strong>order ideal</strong>) if for all <span class="math inline">x \in Q</span> and <span class="math inline">y \in P</span>:<p><span class="math display">y \leqslant x \implies y \in Q</span><p>Dually, we say <span class="math inline">Q</span> is a <strong>up-set</strong> (or <strong>order filter</strong>) if for all <span class="math inline">x \in Q</span> and <span class="math inline">y \in P</span>:<p><span class="math display">y \geqslant x \implies y \in Q</span><p>You may think of them as a subset “closed” under increase or decrase.<p>For an arbitrary subset <span class="math inline">Q</span> of ordered <span class="math inline">P</span>, define the unary operators <span class="math inline">\downarrow</span> called <strong>down</strong> and <span class="math inline">\uparrow</span> <strong>up</strong> on the subset as:<p><span class="math display">\downarrow Q := \{\ y \in P \ |\ (\exists x \in Q)\ y \leqslant x\ \} \\ \uparrow Q := \{\ y \in P \ |\ (\exists x \in Q)\ y \geqslant x\ \}</span><p>and for <span class="math inline">x \in P</span>:<p><span class="math display">\downarrow x := \{\ y \in P \ |\ y \leqslant x\ \} \\ \uparrow x := \{\ y \in P \ |\ y \geqslant x\ \} \\</span><p>Notice that:<ul><li><span class="math inline">\downarrow Q</span> is the smallest down-set that contains <span class="math inline">Q</span>.<li><span class="math inline">Q</span> is a <strong>down-set</strong> if and only if <span class="math inline">Q =\ \downarrow Q</span>.<li><span class="math inline">\downarrow \{x\} =\ \downarrow x</span>.<li><span class="math inline">Q</span> is a down-set of <span class="math inline">P</span> if and only if <span class="math inline">P \setminus Q</span> is an up-set of <span class="math inline">P</span> (or equivalently, a down-set of <span class="math inline">P^\partial</span>).</ul><p>Down-sets (dually up-sets) of the form <span class="math inline">\downarrow x</span> (dually <span class="math inline">\uparrow x</span>) are called <strong>principal</strong>.<h2 id="def.-ordered-set-of-down-sets">Def. Ordered Set of Down-sets</h2><p>The family of all down-sets of the ordered set <span class="math inline">P</span> is denoted by <span class="math inline">\mathcal{O}(P)</span>. Under the inclusion order, <span class="math inline">\mathcal{O}(P)</span> is an ordered set.<p>When <span class="math inline">P</span> is finite, every non-empty down-set <span class="math inline">Q</span> of <span class="math inline">P</span> is expressible in the form<p><span class="math display">\bigcup_{i=1}^{k} \downarrow x_i</span><p>where <span class="math inline">\{x_1, ..., x_k\} = \text{Max}\ Q</span> is an antichain.<p>Notice that <span class="math inline">\mathcal{O}(P)^\partial \cong \mathcal{O}(P^\partial)</span> as <span class="math inline">A \subseteq</span> iff <span class="math inline">P \setminus A \supseteq P \setminus B</span>.<h2 id="thm.">Thm. ’</h2><p>Let <span class="math inline">P, P_1, P_2</span> be ordered sets. Then<ul><li><span class="math inline">\mathcal{O}(P \oplus \bold{1}) \cong \mathcal{O}(P) \oplus \bold{1}</span><li><span class="math inline">\mathcal{O}(\bold{1} \oplus P) \cong \bold{1} \oplus \mathcal{O}(P)</span><li><span class="math inline">\mathcal{O}(P_1 \sqcup P_2) \cong \mathcal{O}(P_1) \times \mathcal{O}(P_2)</span></ul><h1 id="lattices">Lattices</h1><h2 id="def.-bounds">Def. Bounds</h2><p>Let <span class="math inline">P</span> be an ordered set and <span class="math inline">S \subseteq P</span>. Then, <span class="math inline">x \in P</span> is called an <strong>upper bound of <span class="math inline">S</span></strong> if <span class="math inline">s \leqslant x</span> for all <span class="math inline">s \in S</span>. <strong>Lower bound</strong> is defined dually.<p>The set of all upper bounds of <span class="math inline">S</span> is denoted by <span class="math inline">S^+</span> and the set of all lower bounds denoted by <span class="math inline">S^-</span>.<p>The least element of <span class="math inline">S^+</span>, if exists, is called the <strong>supremum</strong> (or <strong>least upper bound</strong>) of <span class="math inline">S</span> denoted <span class="math inline">\sup S</span>. Dually, the greatest element of <span class="math inline">S^-</span> is called <strong>infimum</strong> of <span class="math inline">S</span> denoted <span class="math inline">\inf S</span>.<p>Notice that:<ul><li>Since <span class="math inline">\leqslant</span> is transitive, <span class="math inline">S^+</span> is always an up-set and <span class="math inline">S^-</span> is a down-set.</ul><h2 id="notation.-join-and-meet">Notation. Join and Meet</h2><p>If exists, we will denote <span class="math inline">\sup \{x, y\}</span> with <span class="math inline">x \vee y</span> read as <span class="math inline">x</span> <strong>join</strong> <span class="math inline">y</span>. Similarly, we will denote <span class="math inline">\inf \{x, y\}</span> with <span class="math inline">x \wedge y</span> read as <span class="math inline">x</span> <strong>meet</strong> <span class="math inline">y</span>.<p>Similarly, we will also utilize <span class="math inline">\bigvee S</span> and <span class="math inline">\bigwedge S</span> for <span class="math inline">\sup S</span> and <span class="math inline">\inf S</span>.<h2 id="def.-lattice-and-complete-lattice">Def. Lattice and Complete Lattice</h2><p>Let <span class="math inline">P</span> be a non-empty (partially) ordered set.<ul><li>If join and meet exist for all <span class="math inline">x,y \in P</span>, then <span class="math inline">P</span> is called a <strong>lattice</strong>.<li>If join of and meet of exist for all <span class="math inline">S \subseteq P</span>, then <span class="math inline">P</span> is called a <strong>complete lattice</strong>.</ul><h2 id="def.-axiomatic-definition">Def. Axiomatic Definition</h2><blockquote><p>From <strong>A Course in Universal Algebra</strong>.</blockquote><p>A non-empty set <span class="math inline">L</span> with two binary operations <span class="math inline">\vee</span> and <span class="math inline">\wedge</span> on <span class="math inline">L</span> is called a <strong>lattice</strong> if it satisfies:<ul><li><p><strong>(commutative laws)</strong><br><span class="math inline">x \vee y \approx y \vee x</span><br><span class="math inline">x \wedge y \approx y \wedge x</span><li><p><strong>(associative laws)</strong><br><span class="math inline">x \vee (y \vee z) \approx x \vee (y \vee z)</span><br><span class="math inline">x \wedge (y \wedge z) \approx x \wedge (y \wedge z)</span><li><p><strong>(idempotent laws)</strong><br><span class="math inline">x \vee x \approx x</span><br><span class="math inline">x \wedge x \approx x</span><li><p><strong>(absorption laws)</strong><br><span class="math inline">x \approx x \vee (x \wedge y)</span><br><span class="math inline">x \approx x \wedge (x \vee y)</span></ul>