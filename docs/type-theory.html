<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><meta charset="utf-8"><link href="https://www.howion.com/favicon.svg" rel="icon" type="image/svg+xml"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><title>Type Theory</title><style>html{color:#1a1a1a;background-color:#fdfdfd}body{margin:0 auto;max-width:36em;padding-left:50px;padding-right:50px;padding-top:50px;padding-bottom:50px;hyphens:auto;overflow-wrap:break-word;text-rendering:optimizeLegibility;font-kerning:normal}@media (max-width:600px){body{font-size:.9em;padding:12px}h1{font-size:1.8em}}@media print{html{background-color:#fff}body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}p{margin:1em 0}a{color:#1a1a1a}a:visited{color:#1a1a1a}img{max-width:100%}svg{height:auto;max-width:100%}h1,h2,h3,h4,h5,h6{margin-top:1.4em}h5,h6{font-size:1em;font-style:italic}h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-family:Menlo,Monaco,Consolas,'Lucida Console',monospace;font-size:85%;margin:0;hyphens:manual}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible;overflow-wrap:normal}.sourceCode{background-color:transparent;overflow:visible}hr{border:none;border-top:1px solid #1a1a1a;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}header{margin-bottom:4em;text-align:center}#TOC li{list-style:none}#TOC ul{padding-left:1.3em}#TOC>ul{padding-left:0}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}div.columns{display:flex;gap:min(4vw,1.5em)}div.column{flex:auto;overflow-x:auto}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list[class]{list-style:none}ul.task-list li input[type=checkbox]{font-size:inherit;width:.8em;margin:0 .8em .2em -1.6em;vertical-align:middle}</style><style>@import url(https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap);html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility}svg{shape-rendering:geometricPrecision;text-rendering:geometricPrecision}a,h1,h2,h3,h4,h5,h6,img,p{box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:inherit;-moz-osx-font-smoothing:inherit;backface-visibility:hidden;transform:translateZ(0);user-drag:none}img{display:block;max-width:100%;image-rendering:crisp-edges;image-rendering:pixelated;-webkit-touch-callout:none;-webkit-user-drag:none;user-select:none}*{border-collapse:inherit}*,:after,:before{box-sizing:inherit}svg{display:inline-block;fill:currentColor}a,button{-webkit-tap-highlight-color:transparent}:where(code,kbd,samp,pre){font-size:1em}canvas,picture,svg,video{max-width:100%;display:block}:where(article,aside,details,figcaption,figure,footer,header,main,menu,nav,section){display:block}a{text-decoration:none}a:hover{text-decoration:underline}.toc a{color:#ffffe3}.toc a:visited{color:#ffffe3}.content a{color:#0af}.content a:visited{color:#0af}html{margin:0;padding:0;padding-bottom:4em;background-color:#10100e;color:#ffffe3!important}body{padding:0 24px;margin:0 auto;max-width:912px;font-size:16px;font-family:Inter,sans-serif;font-optical-sizing:auto;font-weight:400;font-style:normal;line-height:1.5}blockquote{background-color:transparent;border-left:2.5px solid #ffffe3;padding:0 .25em 0 1em;margin:0 0 1em 0;opacity:.5;color:inherit}h1{font-size:4em;line-height:1.25;margin-top:1.5em;margin-bottom:.25em}p{line-height:1.5}h1:first-child{margin-top:.5em}h2{border-bottom:2px solid #ffffe3;padding-bottom:.25em;margin-top:1.5em}h1{break-before:page}h2,h3,h4,h5,h6{break-before:auto}details>p>br{display:none!important}details>summary{color:#ffffe3;cursor:pointer}details{margin-top:2em!important;color:rgba(255,255,227,.5)}nav{margin-top:2em;color:inherit}nav>ul>li>a{opacity:1}nav a{color:inherit;opacity:.5}nav>ul>li{margin-top:1em}nav>ul>li>a{font-weight:600}::selection{background-color:#ffffe3;color:#10100e}.katex,.katex .katex-html,.katex .katex-mathml{line-height:1.5;vertical-align:baseline}.katex{display:inline}.katex .katex-html{display:inline}@media print{.katex{transform:scale(1);transform-origin:left baseline}html{background-color:#fff!important;color:#000!important}h1{margin-top:.25em!important}h2{border-color:#000!important}.toc a{color:#000}.toc a:visited{color:#000!important}details{color:rgba(0,0,0,.5)!important}details>summary{color:#000!important}blockquote{border-color:rgba(0,0,0,.5)!important}}</style><style id="page_style">@page{margin:0;padding:.325in .325in;size:10in 13in}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous"><script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){const t={displayMode:!1,throwOnError:!1,macros:[],fleqn:!1};function e(e){if("SPAN"!==e.tagName)return;const n=e.classList.contains("display"),o=e.firstChild,l=Object.assign({},t);l.displayMode=n;return katex.renderToString(o.textContent,l)}const n=document.querySelectorAll(".math"),o=n.length;let l=0;function s(t){const a=Math.min(l+50,o);for(;l<a;l++){const t=n[l];t.innerHTML=e(t)}l<o&&("function"==typeof requestIdleCallback?requestIdleCallback(s,{timeout:1e3}):setTimeout(s,0))}"function"==typeof requestIdleCallback?requestIdleCallback(s,{timeout:1e3}):setTimeout(s,0)})</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script><h1>Table of Contents</h1><nav class="toc" role="doc-toc"><ul><li><a href="#type-theory" id="toc-type-theory">Type Theory</a><ul><li><a href="#resources" id="toc-resources">Resources</a></ul><li><a href="#martin-löfs-dependent-type-theory" id="toc-martin-löfs-dependent-type-theory">(Martin-Löf’s) Dependent Type Theory</a><ul><li><a href="#fundamental-definitions" id="toc-fundamental-definitions">Fundamental Definitions</a><ul><li><a href="#def.-judgments" id="toc-def.-judgments">Def. Judgments</a><li><a href="#def.-context" id="toc-def.-context">Def. Context</a><li><a href="#def.-type-families" id="toc-def.-type-families">Def. Type Families</a><li><a href="#def.-section" id="toc-def.-section">Def. Section</a></ul><li><a href="#inference-rules" id="toc-inference-rules">Inference Rules</a><ul><li><a href="#rules-about-contexts-types-and-elements" id="toc-rules-about-contexts-types-and-elements">Rules about contexts, types and elements</a><li><a href="#rules-that-postulate-judgmental-equality-is-an-equivalence-relation" id="toc-rules-that-postulate-judgmental-equality-is-an-equivalence-relation">Rules that postulate judgmental equality is an equivalence relation</a><li><a href="#variable-conversion-rules" id="toc-variable-conversion-rules">Variable Conversion Rules</a><li><a href="#substitution-rules" id="toc-substitution-rules">Substitution Rules</a><li><a href="#def.-fiber" id="toc-def.-fiber">Def. Fiber</a><li><a href="#weakening" id="toc-weakening">Weakening</a><li><a href="#the-generic-elements-variable-rule" id="toc-the-generic-elements-variable-rule">The Generic Elements (Variable Rule)</a></ul><li><a href="#derivations" id="toc-derivations">Derivations</a></ul></ul></nav><div class="content"><h1 id="type-theory">Type Theory</h1><h2 id="resources">Resources</h2><ul><li><strong>Introduction to Homotopy Type Theory</strong> by Egbert Rĳke<li><strong>Types and Programming Languages</strong> by Benjamin C. Pierce<li>Open Source <a href="https://homotopytypetheory.org/book/"><strong>Homotopy Type Theory: Univalent Foundations of Mathematics</strong></a> by various collaborators.</ul><!-- ## Notation --><h1 id="martin-löfs-dependent-type-theory">(Martin-Löf’s) Dependent Type Theory</h1><h2 id="fundamental-definitions">Fundamental Definitions</h2><h3 id="def.-judgments">Def. Judgments</h3><p>There are four kinds of <strong>judgments</strong> in Martin-Löf’s dependent type theory.<ol type="1"><li><span class="math inline">A</span> is a (well-formed) <strong>type</strong> in <strong>context</strong> <span class="math inline">\Gamma</span>, expressed as:</ol><p><span class="math display">\Gamma \vdash A : \mathcal{T}</span><ol start="2" type="1"><li><span class="math inline">A</span> and <span class="math inline">B</span> are <strong>judgmentally equal types</strong> in context <span class="math inline">\Gamma</span>. We express this judgment as:</ol><p><span class="math display">\Gamma \vdash A \doteq B : \mathcal{T}</span><ol start="3" type="1"><li><span class="math inline">a</span> is an <strong>element</strong> of type <span class="math inline">A</span> in context <span class="math inline">\Gamma</span>, expressed as:</ol><p><span class="math display">\Gamma \vdash a : A</span><ol start="4" type="1"><li><span class="math inline">a</span> and <span class="math inline">b</span> are <strong>judgmentally equal elements</strong> of type <span class="math inline">A</span> in context <span class="math inline">\Gamma</span>, expressed as:</ol><p><span class="math display">\Gamma \vdash a \doteq b : A</span><blockquote><p>Notice that all judgments are context-dependent.</blockquote><h3 id="def.-context">Def. Context</h3><p>A <strong>context</strong> is a finite list of <strong>variable declarations</strong>.<p><span class="math display">\begin{array}{l} x_1: A_1, \\ x_2: A_2 (x_1), \\ \vdots \\ x_n: A_n (x_1, ..., x_{n-1}) \end{array}</span><p>that satisfy the condition, for each <span class="math inline">1 \leq k \leq n</span> we can derive the judgment:<p><span class="math display">(x_1: A_1), ..., (x_{k-1}: A_{k-1} (x_1, ..., x_{k-2})) \vdash A_k (x_1, ..., x_{k-1}) : \mathcal{T}</span><p>with the inference rules of our type theory. We may also use variable names as long as no variable is declared more than once.<p>An context of length <span class="math inline">0</span> which declares no variables is called the <strong>empty context</strong>.<h3 id="def.-type-families">Def. Type Families</h3><p>Let <span class="math inline">A</span> be a type in context <span class="math inline">\Gamma</span>. A <strong>family (of types) over <span class="math inline">A</span></strong> in context <span class="math inline">\Gamma</span> is a type <span class="math inline">B(x)</span> in context <span class="math inline">\textcolor{gray}{(}\Gamma, x : A\textcolor{gray}{)}</span>. More explicitly, given:<p><span class="math display">\Gamma, x: A \vdash B(x) : \mathcal{T}</span><p>we say that <span class="math inline">B(x)</span> is family of types over <span class="math inline">A</span> in context <span class="math inline">\Gamma</span>. Alternatively, we say <span class="math inline">B(x)</span> is a type <strong>indexed</strong> by <span class="math inline">x: A</span>, in context <span class="math inline">\Gamma</span>.<h3 id="def.-section">Def. Section</h3><p>Let <span class="math inline">B</span> be a family (of types) over <span class="math inline">A</span> in context <span class="math inline">\Gamma</span>. A <strong>section</strong> of the family <span class="math inline">B</span> is an element of type <span class="math inline">B(x)</span> in context <span class="math inline">\textcolor{gray}{(}\Gamma, x : A\textcolor{gray}{)}</span>.<h2 id="inference-rules">Inference Rules</h2><p>These rules are known as <strong>structural rules</strong> of type theory. There are six sets of inference rules:<ol type="1"><li>Rules about contexts, types and elements<li>Rules that postulate judgmental equality is an equivalence relation<li>Variable conversion rules<li>Substitution rules<li>Weakening rules<li>The generic element (or variable rule)</ol><h3 id="rules-about-contexts-types-and-elements">Rules about contexts, types and elements</h3>$$ <span class="math display">\begin{array}{ccc} \begin{array}{ccc} \Gamma, x: A \vdash B(x): \mathcal{T} \\ \hline \Gamma \vdash A: \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): \mathcal{T} \\ \hline \Gamma \vdash A: \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): \mathcal{T} \\ \hline \Gamma \vdash B: \mathcal{T} \end{array} \\ \\ \begin{array}{ccc} \Gamma \vdash a: A \\ \hline \Gamma \vdash A: \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): A \\ \hline \Gamma \vdash a: A \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): A \\ \hline \Gamma \vdash b: A \end{array} \end{array}</span><p>$$<h3 id="rules-that-postulate-judgmental-equality-is-an-equivalence-relation">Rules that postulate judgmental equality is an equivalence relation</h3>$$ <span class="math display">\begin{array}{ccc} \begin{array}{ccc} \Gamma \vdash A: \mathcal{T} \\ \hline \Gamma \vdash (A \doteq A): \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): \mathcal{T} \\ \hline \Gamma \vdash (B \doteq A): \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (A \doteq B): \mathcal{T} \qquad \Gamma \vdash (B \doteq C): \mathcal{T} \\ \hline \Gamma \vdash (A \doteq C): \mathcal{T} \end{array} \\ \\ \begin{array}{ccc} \Gamma \vdash a: A \\ \hline \Gamma \vdash (a \doteq a): \mathcal{T} \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (a \doteq b): A \\ \hline \Gamma \vdash (b \doteq a): A \end{array} &amp; \begin{array}{ccc} \Gamma \vdash (a \doteq b): A \qquad \Gamma \vdash (b \doteq c): A \\ \hline \Gamma \vdash (a \doteq c): A \end{array} \end{array}</span><p>$$<h3 id="variable-conversion-rules">Variable Conversion Rules</h3><p><span class="math display">\begin{array}{ccc} \Gamma \vdash (A \doteq A&#39;): \mathcal{T} \qquad \Gamma, x: A, \Delta \vdash B(x): \mathcal{T} \\ \hline \Gamma, x: A&#39;, \Delta \vdash B(x): \mathcal{T} \end{array}</span><p>Let <span class="math inline">\mathcal{J}</span> denote any one of the 4 judgments given above, then<p><span class="math display">\begin{array}{ccc} \Gamma \vdash (A \doteq A&#39;): \mathcal{T} \qquad \Gamma, x: A, \Delta \vdash \mathcal{J} \\ \hline \Gamma, x: A, \Delta \vdash \mathcal{J} \end{array}</span><h3 id="substitution-rules">Substitution Rules</h3><p><span class="math display">\begin{array}{ccc} \Gamma \vdash a: A \qquad \Gamma, x: A, \Delta \vdash \mathcal{J} \\ \hline \Gamma, \Delta[a/x] \vdash \mathcal{J}[a/x] \end{array}</span><p>and<p><span class="math display">\begin{array}{ccc} \Gamma \vdash (a \doteq a&#39;): A \qquad \Gamma, x: A, \Delta \vdash B: \mathcal{T} \\ \hline \Gamma, \Delta[a/x] \vdash (B[a/x] \doteq B[a&#39;/x]): \mathcal{T} \end{array}</span><p><span class="math display">\begin{array}{ccc} \Gamma \vdash (a \doteq a&#39;): A \qquad \Gamma, x: A, \Delta \vdash b: B \\ \hline \Gamma, \Delta[a/x] \vdash (b[a/x] \doteq b[a&#39;/x]): B[a/x] \end{array}</span><h3 id="def.-fiber">Def. Fiber</h3><p>Let <span class="math inline">B</span> be a family of types over <span class="math inline">A</span> in context <span class="math inline">\Gamma</span> and <span class="math inline">a: A</span>. Then we say that <span class="math inline">B[a/x]</span> or simply <span class="math inline">B(a)</span> is the <strong>fiber</strong> of <span class="math inline">B</span> at <span class="math inline">a</span>.<p>When <span class="math inline">b</span> is a section of <span class="math inline">B</span>, we call the element <span class="math inline">b[a/x]</span> or simply <span class="math inline">b(a)</span> the <strong>value</strong> of <span class="math inline">b</span> at <span class="math inline">a</span>.<h3 id="weakening">Weakening</h3><p><span class="math display">\begin{array}{c} \Gamma \vdash A: \mathcal{T} \qquad \Gamma, \Delta \vdash \mathcal{J} \\ \hline \Gamma, x: A, \Delta \vdash \mathcal{J} \end{array}</span><blockquote><p><strong>constant family</strong> or the <strong>trivial family</strong> <span class="math inline">B</span>.</blockquote><h3 id="the-generic-elements-variable-rule">The Generic Elements (Variable Rule)</h3><p><span class="math display">\begin{array}{c} \Gamma \vdash A: \mathcal{T} \\ \hline \Gamma, x: A \vdash x: A \end{array}</span><h2 id="derivations">Derivations</h2><p>A <strong>derivation</strong> is basically an inference rule (but as a meta-theorem) derived from the inference rules given above.<p>A rule is called <strong>derivable</strong> if we have a derivation for it.<ul><li>Changing Variables<li>Interchanging Variables</ul><blockquote><p>See the “Introduction to Homotopy Type Theory” for details and examples.</blockquote></div>