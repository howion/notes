<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><meta charset="utf-8"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><title>Propositional Logic</title><style>html{color:#1a1a1a;background-color:#fdfdfd}body{margin:0 auto;max-width:36em;padding-left:50px;padding-right:50px;padding-top:50px;padding-bottom:50px;hyphens:auto;overflow-wrap:break-word;text-rendering:optimizeLegibility;font-kerning:normal}@media (max-width:600px){body{font-size:.9em;padding:12px}h1{font-size:1.8em}}@media print{html{background-color:#fff}body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}p{margin:1em 0}a{color:#1a1a1a}a:visited{color:#1a1a1a}img{max-width:100%}svg{height:auto;max-width:100%}h1,h2,h3,h4,h5,h6{margin-top:1.4em}h5,h6{font-size:1em;font-style:italic}h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-family:Menlo,Monaco,Consolas,'Lucida Console',monospace;font-size:85%;margin:0;hyphens:manual}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible;overflow-wrap:normal}.sourceCode{background-color:transparent;overflow:visible}hr{border:none;border-top:1px solid #1a1a1a;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}header{margin-bottom:4em;text-align:center}#TOC li{list-style:none}#TOC ul{padding-left:1.3em}#TOC>ul{padding-left:0}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}div.columns{display:flex;gap:min(4vw,1.5em)}div.column{flex:auto;overflow-x:auto}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list[class]{list-style:none}ul.task-list li input[type=checkbox]{font-size:inherit;width:.8em;margin:0 .8em .2em -1.6em;vertical-align:middle}</style><style>@import url(https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap);html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility}svg{shape-rendering:geometricPrecision;text-rendering:geometricPrecision}a,h1,h2,h3,h4,h5,h6,img,p{box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:inherit;-moz-osx-font-smoothing:inherit;backface-visibility:hidden;transform:translateZ(0);user-drag:none}img{display:block;max-width:100%;image-rendering:crisp-edges;image-rendering:pixelated;-webkit-touch-callout:none;-webkit-user-drag:none;user-select:none}*{border-collapse:inherit}*,:after,:before{box-sizing:inherit}svg{display:inline-block;fill:currentColor}a,button{-webkit-tap-highlight-color:transparent}:where(code,kbd,samp,pre){font-size:1em}canvas,picture,svg,video{max-width:100%;display:block}:where(article,aside,details,figcaption,figure,footer,header,main,menu,nav,section){display:block}a{text-decoration:none}a:hover{text-decoration:underline}html{margin:0;padding:0;padding-bottom:4em}body{padding:0 24px;margin:0 auto;max-width:912px;font-size:16px;font-family:Inter,sans-serif;font-optical-sizing:auto;font-weight:400;font-style:normal;line-height:1.5}blockquote{background-color:rgba(0,0,0,.05);border-left:.25em solid rgba(0,0,0,.05);padding:.25em .25em .25em 1em;margin:0 0 1em 0}h1{font-size:4em;margin-top:1em;line-height:1.25}h2{border-bottom:2px solid #000;padding-bottom:.25em;margin-top:1.5em}h1{break-before:page}h2,h3,h4,h5,h6{break-before:auto}</style><style id="page_style">@page{margin:0;padding:.25in .325in;size:10in 13in}</style><script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){for(var e=document.getElementsByClassName("math"),t=[],a=0;a<e.length;a++){var n=e[a].firstChild;"SPAN"==e[a].tagName&&katex.render(n.data,e[a],{displayMode:e[a].classList.contains("display"),throwOnError:!1,macros:t,fleqn:!1})}})</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><h1>Table of Contents</h1><nav role="doc-toc"><ul><li><a href="#syntax-and-semantics" id="toc-syntax-and-semantics">Syntax and Semantics</a><ul><li><a href="#introduction" id="toc-introduction">Introduction</a><li><a href="#def.-symbols" id="toc-def.-symbols">Def. Symbols</a><li><a href="#def.-the-set-of-propositional-formulas" id="toc-def.-the-set-of-propositional-formulas">Def. <em>The</em> Set of Propositional Formulas</a><li><a href="#def.-syntactic-identity" id="toc-def.-syntactic-identity">Def. Syntactic Identity</a><li><a href="#def.-operators" id="toc-def.-operators">Def. Operators</a><li><a href="#def.-subformula" id="toc-def.-subformula">Def. Subformula</a><li><a href="#thm.-principle-of-induction-on-formulas" id="toc-thm.-principle-of-induction-on-formulas">Thm. Principle of Induction on Formulas</a><li><a href="#def.-formation-sequence-for-propositional-formulas" id="toc-def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</a><ul><li><a href="#example" id="toc-example">Example</a><li><a href="#thm.-existence-of-formation-sequence" id="toc-thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</a></ul><li><a href="#def.-valuation" id="toc-def.-valuation">Def. Valuation</a><li><a href="#def.-evaluation" id="toc-def.-evaluation">Def. Evaluation</a><li><a href="#def.-satisfiability" id="toc-def.-satisfiability">Def. Satisfiability</a><li><a href="#def.-tautology-and-contradiction" id="toc-def.-tautology-and-contradiction">Def. Tautology and Contradiction</a><li><a href="#def.-entails" id="toc-def.-entails">Def. Entails</a><li><a href="#def.-semantic-equivalence" id="toc-def.-semantic-equivalence">Def. Semantic Equivalence</a><ul><li><a href="#exercise" id="toc-exercise">Exercise</a><li><a href="#exercise-distributivity-rules" id="toc-exercise-distributivity-rules">Exercise (Distributivity Rules)</a></ul><li><a href="#def.-a-set-of-formulas" id="toc-def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</a><ul><li><a href="#thm.-semantic-modus-ponens" id="toc-thm.-semantic-modus-ponens">Thm. <em>Semantic</em> Modus Ponens</a><li><a href="#thm." id="toc-thm.">Thm. ?</a><li><a href="#thm.-semantic-monotonicity" id="toc-thm.-semantic-monotonicity">Thm. <em>Semantic</em> Monotonicity</a><li><a href="#thm.-semantic-transitivity" id="toc-thm.-semantic-transitivity">Thm. <em>Semantic</em> Transitivity</a></ul><li><a href="#thm.-semantic-deduction-theorem" id="toc-thm.-semantic-deduction-theorem">Thm. <em>Semantic</em> Deduction Theorem</a></ul><li><a href="#derivations" id="toc-derivations">Derivations</a></ul></nav><h1 id="syntax-and-semantics">Syntax and Semantics</h1><blockquote><p>You may skip this chapter, but it is suggested to skim it for the notations.</blockquote><h2 id="introduction">Introduction</h2><p>Theorems and definitions we prove and define here are actually metatheorems and metadefinitions in our metalanguage. You may assume our metalangauge is first-order or second-order logic in which we define propositional logic which is sometimes called <strong>zeroth-order logic</strong>. Note that we haven’t yet shown propositional logic is a subset of our metalanguage. It is just, kind of, nonsense syntax at this moment.<h2 id="def.-symbols">Def. Symbols</h2><p>Syntactically, we will use the symbols<ul><li><span class="math inline">\bot</span> called <strong>bottom</strong> or simply <strong>bot</strong> to denote falsity <em>in our syntactic model</em>,<li><span class="math inline">\top</span> called <strong>top</strong> to denote truth <em>in our syntactic model</em>,<li><span class="math inline">\neg</span> called <strong>negation</strong> to denote <em>negation</em>,<li><span class="math inline">\to</span> called <strong>material implication</strong> to denote <em>implication</em>,</ul><p>Semantically, we will use the symbols<ul><li><span class="math inline">\mathbb{T}</span> called <strong>true</strong> to denote <em>semantic truth</em>, and<li><span class="math inline">\mathbb{F}</span> called <strong>false</strong> to denote <em>semantic falsity</em>.</ul><h2 id="def.-the-set-of-propositional-formulas">Def. <em>The</em> Set of Propositional Formulas</h2><blockquote><p>For simplicity, you may want to consider a formula as a string of symbols such that it is an element of the set <span class="math inline">\text{Form}(\mathcal{P})</span> given below. There is many ways to define the set of propositional formulas, we’ll stick with this one.</blockquote><p>Given a (possibly empty) countable set of <strong>atomic formulas</strong> (or <strong>prime formulas</strong>) <span class="math inline">\mathcal{P}</span>, the set <span class="math inline">\text{Form}(\mathcal{P})</span> of <strong>formulas</strong> of propositional logic is the <em>smallest set</em>, defined <em>inductively</em>, such that:<ol type="1"><li><span class="math inline">\mathcal{P} \subseteq \text{Form}(\mathcal{P})</span>,<li>If <span class="math inline">F \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">\neg F \in \text{Form}(\mathcal{P})</span>,<li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \land G) \text{Form}(\mathcal{P})</span></ol><blockquote><p>This definition of formulas until here suffice as we can define other operators from <span class="math inline">\neg</span> and <span class="math inline">\land</span>. Indeed, we will sometimes use only these when proving theorems (or even defining concepts). In practice, we also further assume:</blockquote><ol start="4" type="1"><li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \lor G) \in \text{Form}(\mathcal{P})</span><li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \to G) \in \text{Form}(\mathcal{P})</span></ol><blockquote><p>With just the NAND operator <span class="math inline">\bar{\land}</span> alone, it is possible to build other logical operators, so that (2)-(3) can be reduced to single statement with NAND.</blockquote><p>When we refer an object <span class="math inline">F</span> as a (propositional) <strong>formula</strong>, we simply mean it is an element of <span class="math inline">\text{Form}(\mathcal{P})</span> for some set of atomic variables <span class="math inline">\mathcal{P}</span>.<p>Sometimes, we will omit the use of brackets for readibility, so that, for example, <span class="math inline">A \land B</span> should be understood as the formula <span class="math inline">(A \land B)</span>.<h2 id="def.-syntactic-identity">Def. Syntactic Identity</h2><p>With <span class="math inline">=</span>, we will denote the <strong>syntactic identity</strong>. That is, if <span class="math inline">F</span> and <span class="math inline">G</span> are strings and are formulas, then <span class="math inline">F=G</span> will simply denote they are strings of symbols of same lenght with same symbols in each place. Notice that this is a <em>semantic defintion</em> for our syntactic model.<h2 id="def.-operators">Def. Operators</h2><p>Given the logical operators <span class="math inline">\neg</span> and <span class="math inline">\land</span> and the atomic variable <span class="math inline">\bot</span>, we can <em>define</em>, for formulas <span class="math inline">F</span> and <span class="math inline">G</span><ul><li><span class="math inline">\top \triangleq \neg \bot</span>,<li><span class="math inline">(F \lor G) \triangleq \neg (\neg F \land \neg G)</span>, and<li><span class="math inline">(F \to G) \triangleq (\neg F \lor Q)</span></ul><blockquote><p>Notice that we have just defined syntactic abbreviation, didn’t prove anything.</blockquote><h2 id="def.-subformula">Def. Subformula</h2><p>Let <span class="math inline">F \in \text{Form}(\mathcal{P})</span> be a formula. Then the set <span class="math inline">\text{Sub}(F)</span> of <strong>subformulas</strong> of <span class="math inline">F</span> is the smallest set, such that<ul><li><span class="math inline">F \in \text{Sub}(F)</span>,<li>If <span class="math inline">F = \neg G</span>, then <span class="math inline">G \in \text{Sub}(F)</span>.<li>If <span class="math inline">F = (G \land H)</span>, then <span class="math inline">G,H \in \text{Sub}(F)</span>.</ul><blockquote><p>Here, we have just defined subformula for (1)-(3) above, it should be clear what a subformula is for an extended definition.</blockquote><p>The set <span class="math inline">\text{Sub}^+(F)</span> of <strong>proper subformulas</strong> is defined as <span class="math inline">\text{Sub}(F) \setminus \{F\}</span>.<h2 id="thm.-principle-of-induction-on-formulas">Thm. Principle of Induction on Formulas</h2><p>Since we are going to use induction heavily, we will prove that if <span class="math inline">\phi</span> is any property which<ol type="1"><li>Holds for all atomic formulas,<li>If holds for <span class="math inline">F</span>, it also holds for <span class="math inline">\neg F</span>, and<li>If holds for <span class="math inline">F</span> and <span class="math inline">G</span>, it also holds for <span class="math inline">(F \land G)</span>,</ol><p>Then <span class="math inline">\phi</span> holds for all formulas (of propositional logic).<details><summary><b>Proof</b></summary><br>TODO:</details><h2 id="def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</h2><p>A finite sequence <span class="math inline">(F_0, ..., F_n)</span> is called a <strong>formation sequence</strong> for the formula <span class="math inline">F</span> if <span class="math inline">F = F_n</span> and for all <span class="math inline">i \leq n</span>, either<ol type="1"><li><span class="math inline">F_i</span> is atomic formula, or<li>there exists <span class="math inline">j,k \lt i</span> such that, either<ol type="1"><li><span class="math inline">F_i = \neg F_j</span>,<li><span class="math inline">F_i = (F_j \land F_k)</span>.</ol></ol><h3 id="example">Example</h3><p>For example, for atomics <span class="math inline">p_0, p_1, p_2 \in \mathcal{P}</span> the sequence<p><span class="math display">(p_0, p_1, (p_1 \land p_0), \neg (p_1 \land p_0))</span><p>is a formation sequence for <span class="math inline">\neg (p_1 \land p_0)</span>, as is<p><span class="math display">(p_0, p_1, p_0,(p_1 \land p_0), (p_0 \land p_1), \neg (p_1 \land p_0))</span><h3 id="thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</h3><p>Every propositional formula has a formation sequence.<h2 id="def.-valuation">Def. Valuation</h2><p>Given a set <span class="math inline">\mathcal{P}</span> of atomic variables, a <strong>valuation</strong> (or <strong>assignment</strong>) <span class="math inline">v</span> is a function<p><span class="math display">v: \mathcal{P} \to \mathcal{V} = \{\mathbb{T}, \mathbb{F}\}</span><p>which simply assigns semantic <strong>true</strong> or <strong>false</strong> to atomic variables.<p>So from now on, depending on context, we may assume <span class="math inline">\bot \in \mathcal{P}</span> and always define <span class="math inline">v(\bot) = \mathbb{F}</span>, thus <span class="math inline">v(\top) = \mathbb{T}</span>.<blockquote><p>Ponder what would happen if it were the case that <span class="math inline">\mathcal{V} = [0,1]</span> where <span class="math inline">\mathbb{F} = 0 \in \R</span> and <span class="math inline">\mathbb{T}=1</span>. Obviously, most of our definitions and theorems wouldn’t make sense in this setting.</blockquote><h2 id="def.-evaluation">Def. Evaluation</h2><p>Let <span class="math inline">F</span> be a formula and <span class="math inline">v</span> some valuation. We will abuse notation and also use <span class="math inline">v(F)</span> for the <strong>evaluation</strong> of a formula <span class="math inline">F</span>, defined naturally.<p>If <span class="math inline">v(F) = \mathbb{T}</span>, then we say <span class="math inline">v</span> <strong>models</strong> <span class="math inline">F</span> denoted by <span class="math inline">v \models F</span>. Equivalently, we say <span class="math inline">F</span> <strong>holds</strong> under <span class="math inline">v</span>.<blockquote><p>Notice that this is the first time we have defined the sign <span class="math inline">\models</span>.</blockquote><h2 id="def.-satisfiability">Def. Satisfiability</h2><p>A formula <span class="math inline">F</span> is said to be <strong>satisfiable</strong> if there exists an valuation <span class="math inline">v</span> such that <span class="math inline">v \models F</span>. Otherwise, it is called <strong>unsatisfiable</strong>.<h2 id="def.-tautology-and-contradiction">Def. Tautology and Contradiction</h2><ul><li>A formula <span class="math inline">F</span> is said to be a <strong>tautology</strong> if it holds under all valuations. This is denoted by <span class="math inline">\models F</span>.<li>Similarly, a formula is said to be a <strong>contradiction</strong> if it holds under no valuation. Denoted <span class="math inline">\not \models F</span><li>A formula which is satisfiable but not a tautology is called <strong>contingent</strong>.</ul><h2 id="def.-entails">Def. Entails</h2><p>We say a formula <span class="math inline">F</span> <strong>entails</strong> the formula <span class="math inline">G</span> denoted by <span class="math inline">F \models G</span> if every valuation which models <span class="math inline">F</span> also models <span class="math inline">G</span>. In this case, we also say <span class="math inline">G</span> is a <strong>consequence</strong> of <span class="math inline">F</span>.<blockquote><p>Notice how we are <strong>overloading</strong> (and will keep on overloading) the infix notation <span class="math inline">\models</span> with valuations, formulas etc. So the elements left or right handside of “models” sign is context-dependent.</blockquote><h2 id="def.-semantic-equivalence">Def. Semantic Equivalence</h2><p>Let <span class="math inline">F</span> and <span class="math inline">G</span> be formulas. If they entail each other, then we say they are <strong>equivalent</strong>. This is denoted by <span class="math inline">F \equiv G</span>.<h3 id="exercise">Exercise</h3><p><span class="math inline">(F \land G) \equiv (G \land F)</span><h3 id="exercise-distributivity-rules">Exercise (Distributivity Rules)</h3><ul><li><span class="math inline">(F \land (G \lor H)) \equiv ((F \land G) \lor (F \land H))</span><li><span class="math inline">(F \lor (G \land H)) \equiv ((F \lor G) \land (F \lor H))</span></ul><h2 id="def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</h2><p>From now on, when we say <span class="math inline">\Gamma</span> is <strong>a set of formulas</strong>, we will mean <span class="math inline">\Gamma \subseteq \text{Form}(\mathcal{P})</span>. So it is not <em>the</em> set of formulas, but rather <em>a</em> set of formulas.<p>Moreover, we’ll overload the <span class="math inline">\models</span> notation further in respect to this notion. Let <span class="math inline">\Gamma</span> be a set for formulas such that <span class="math inline">\Gamma = \Set{F_0, F_1, ...}</span>, then we say<ul><li>a valuation <span class="math inline">v</span> <strong>models</strong> <span class="math inline">\Gamma</span> denoted by <span class="math inline">v \models \Gamma</span> if <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>,<li><span class="math inline">\Gamma</span> <strong>entails</strong> (a formula) <span class="math inline">G</span> denoted by <span class="math inline">\Gamma \models G</span> if for every valuation <span class="math inline">v</span> such that <span class="math inline">v \models \Gamma</span> implies <span class="math inline">v \models G</span>,<li><span class="math inline">\Gamma</span> is <strong>satisfiable</strong> if there exists a valution <span class="math inline">v</span> such that <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>, and <strong>unsatisfiable</strong> otherwise.</ul><p>Now, let’s look at some basic semantic properties of propositional logic.<h3 id="thm.-semantic-modus-ponens">Thm. <em>Semantic</em> Modus Ponens</h3><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">A, B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Gamma \models (A \to B)</span>, then <span class="math inline">\Gamma \models B</span>.<h3 id="thm.">Thm. ?</h3><p>Let <span class="math inline">\Gamma</span> be a set of formulas. If <span class="math inline">\Delta</span> is satisfiable, then so is every finite subset of it.<h3 id="thm.-semantic-monotonicity">Thm. <em>Semantic</em> Monotonicity</h3><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas such that <span class="math inline">\Gamma \subseteq \Delta</span> and <span class="math inline">A</span> a formula. If <span class="math inline">\Gamma \models A</span> then <span class="math inline">\Delta \models A</span>.<h3 id="thm.-semantic-transitivity">Thm. <em>Semantic</em> Transitivity</h3><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas and <span class="math inline">A,B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Delta \cup \{A\} \models B</span>, then <span class="math inline">\Gamma \cup \Delta \models B</span>.<h2 id="thm.-semantic-deduction-theorem">Thm. <em>Semantic</em> Deduction Theorem</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">A</span> a formula. Then, <span class="math inline">\Gamma \models A</span> if and only if <span class="math inline">\Gamma \cup \{\neg A\}</span> is unsatisfiable.<h1 id="derivations">Derivations</h1>