<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><meta charset="utf-8"><link href="https://www.howion.com/favicon.svg" rel="icon" type="image/svg+xml"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><title>Propositional Logic</title><style>html{color:#1a1a1a;background-color:#fdfdfd}body{margin:0 auto;max-width:36em;padding-left:50px;padding-right:50px;padding-top:50px;padding-bottom:50px;hyphens:auto;overflow-wrap:break-word;text-rendering:optimizeLegibility;font-kerning:normal}@media (max-width:600px){body{font-size:.9em;padding:12px}h1{font-size:1.8em}}@media print{html{background-color:#fff}body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}p{margin:1em 0}a{color:#1a1a1a}a:visited{color:#1a1a1a}img{max-width:100%}svg{height:auto;max-width:100%}h1,h2,h3,h4,h5,h6{margin-top:1.4em}h5,h6{font-size:1em;font-style:italic}h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-family:Menlo,Monaco,Consolas,'Lucida Console',monospace;font-size:85%;margin:0;hyphens:manual}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible;overflow-wrap:normal}.sourceCode{background-color:transparent;overflow:visible}hr{border:none;border-top:1px solid #1a1a1a;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}header{margin-bottom:4em;text-align:center}#TOC li{list-style:none}#TOC ul{padding-left:1.3em}#TOC>ul{padding-left:0}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}div.columns{display:flex;gap:min(4vw,1.5em)}div.column{flex:auto;overflow-x:auto}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list[class]{list-style:none}ul.task-list li input[type=checkbox]{font-size:inherit;width:.8em;margin:0 .8em .2em -1.6em;vertical-align:middle}</style><style>@import url(https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap);html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility}svg{shape-rendering:geometricPrecision;text-rendering:geometricPrecision}a,h1,h2,h3,h4,h5,h6,img,p{box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:inherit;-moz-osx-font-smoothing:inherit;backface-visibility:hidden;transform:translateZ(0);user-drag:none}img{display:block;max-width:100%;image-rendering:crisp-edges;image-rendering:pixelated;-webkit-touch-callout:none;-webkit-user-drag:none;user-select:none}*{border-collapse:inherit}*,:after,:before{box-sizing:inherit}svg{display:inline-block;fill:currentColor}a,button{-webkit-tap-highlight-color:transparent}:where(code,kbd,samp,pre){font-size:1em}canvas,picture,svg,video{max-width:100%;display:block}:where(article,aside,details,figcaption,figure,footer,header,main,menu,nav,section){display:block}a{text-decoration:none}a:hover{text-decoration:underline}html{margin:0;padding:0;padding-bottom:4em}body{padding:0 24px;margin:0 auto;max-width:912px;font-size:16px;font-family:Inter,sans-serif;font-optical-sizing:auto;font-weight:400;font-style:normal;line-height:1.5}blockquote{background-color:transparent;border-left:2.5px solid rgba(0,0,0,.25);padding:0 .25em 0 1em;margin:0 0 1em 0;color:rgba(0,0,0,.625)}h1{font-size:4em;line-height:1.25;margin-top:1.5em;margin-bottom:.25em}h2{border-bottom:2px solid #000;padding-bottom:.25em;margin-top:1.5em}h1{break-before:page}h2,h3,h4,h5,h6{break-before:auto}details>p>br{display:none!important}details>summary{color:#10100e!important;cursor:pointer}details{margin-top:2em!important;color:rgba(0,0,0,.5)}nav>ul>li{margin-top:1em}nav>ul>li>a{font-weight:600}@media print{html{background-color:#fff!important;color:#000!important}h1{margin-top:.25em!important}}</style><style id="page_style">@page{margin:0;padding:.325in .325in;size:10in 13in}</style><script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){for(var e=document.getElementsByClassName("math"),t=[],a=0;a<e.length;a++){var n=e[a].firstChild;"SPAN"==e[a].tagName&&katex.render(n.data,e[a],{displayMode:e[a].classList.contains("display"),throwOnError:!1,macros:t,fleqn:!1})}})</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><h1>Table of Contents</h1><nav role="doc-toc"><ul><li><a href="#syntax-and-semantics" id="toc-syntax-and-semantics">Syntax and Semantics</a><ul><li><a href="#introduction" id="toc-introduction">Introduction</a><li><a href="#def.-symbols" id="toc-def.-symbols">Def. Symbols</a><li><a href="#def.-the-set-of-propositional-formulas" id="toc-def.-the-set-of-propositional-formulas">Def. <em>The</em> Set of Propositional Formulas</a><li><a href="#def.-syntactic-identity" id="toc-def.-syntactic-identity">Def. Syntactic Identity</a><li><a href="#def.-operators" id="toc-def.-operators">Def. Operators</a><li><a href="#def.-subformula" id="toc-def.-subformula">Def. Subformula</a><li><a href="#thm.-principle-of-induction-on-formulas" id="toc-thm.-principle-of-induction-on-formulas">Thm. Principle of Induction on Formulas</a><li><a href="#def.-formation-sequence-for-propositional-formulas" id="toc-def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</a><ul><li><a href="#example" id="toc-example">Example</a><li><a href="#thm.-existence-of-formation-sequence" id="toc-thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</a></ul><li><a href="#def.-valuation" id="toc-def.-valuation">Def. Valuation</a><li><a href="#def.-evaluation" id="toc-def.-evaluation">Def. Evaluation</a><li><a href="#def.-satisfiability" id="toc-def.-satisfiability">Def. Satisfiability</a><li><a href="#def.-tautology-and-contradiction" id="toc-def.-tautology-and-contradiction">Def. Tautology and Contradiction</a><li><a href="#def.-entails" id="toc-def.-entails">Def. Entails</a><li><a href="#def.-semantic-equivalence" id="toc-def.-semantic-equivalence">Def. Semantic Equivalence</a><ul><li><a href="#exercise" id="toc-exercise">Exercise</a><li><a href="#exercise-distributivity-rules" id="toc-exercise-distributivity-rules">Exercise (Distributivity Rules)</a></ul><li><a href="#def.-a-set-of-formulas" id="toc-def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</a><ul><li><a href="#thm.-semantic-modus-ponens" id="toc-thm.-semantic-modus-ponens">Thm. <em>Semantic</em> Modus Ponens</a><li><a href="#thm." id="toc-thm.">Thm. ?</a><li><a href="#thm.-semantic-monotonicity" id="toc-thm.-semantic-monotonicity">Thm. <em>Semantic</em> Monotonicity</a><li><a href="#thm.-semantic-transitivity" id="toc-thm.-semantic-transitivity">Thm. <em>Semantic</em> Transitivity</a></ul><li><a href="#thm.-semantic-deduction-theorem" id="toc-thm.-semantic-deduction-theorem">Thm. <em>Semantic</em> Deduction Theorem</a></ul><li><a href="#derivations" id="toc-derivations">Derivations</a><ul><li><a href="#def.-derives" id="toc-def.-derives">Def. Derives</a><li><a href="#def.-syntactic-proof" id="toc-def.-syntactic-proof">Def. Syntactic Proof</a><ul><li><a href="#example-1" id="toc-example-1">Example</a></ul></ul></ul></nav><h1 id="syntax-and-semantics">Syntax and Semantics</h1><blockquote><p>You may skip this chapter, but it is suggested to skim it for the notations.</blockquote><h2 id="introduction">Introduction</h2><p>Theorems and definitions we prove and define here are actually metatheorems and metadefinitions in our metalanguage. You may assume our metalangauge is first-order or second-order logic in which we define propositional logic which is sometimes called <strong>zeroth-order logic</strong>. Note that we haven’t yet shown propositional logic is a subset of our metalanguage. It is just, kind of, nonsense syntax at this moment.<h2 id="def.-symbols">Def. Symbols</h2><p>Syntactically, we will use the symbols<ul><li><span class="math inline">\bot</span> called <strong>bottom</strong> or simply <strong>bot</strong> to denote falsity <em>in our syntactic model</em>,<li><span class="math inline">\top</span> called <strong>top</strong> to denote truth <em>in our syntactic model</em>,<li><span class="math inline">\neg</span> called <strong>negation</strong> to denote <em>negation</em>,<li><span class="math inline">\to</span> called <strong>material implication</strong> to denote <em>implication</em>,</ul><p>Semantically, we will use the symbols<ul><li><span class="math inline">\mathbb{T}</span> called <strong>true</strong> to denote <em>semantic truth</em>, and<li><span class="math inline">\mathbb{F}</span> called <strong>false</strong> to denote <em>semantic falsity</em>.</ul><h2 id="def.-the-set-of-propositional-formulas">Def. <em>The</em> Set of Propositional Formulas</h2><blockquote><p>For simplicity, you may want to consider a formula as a string of symbols such that it is an element of the set <span class="math inline">\text{Form}(\mathcal{P})</span> given below. There is many ways to define the set of propositional formulas, we’ll stick with this one.</blockquote><p>Given a (possibly empty) countable set of <strong>atomic formulas</strong> (or <strong>prime formulas</strong>) <span class="math inline">\mathcal{P}</span>, the set <span class="math inline">\text{Form}(\mathcal{P})</span> of <strong>formulas</strong> of propositional logic is the <em>smallest set</em>, defined <em>inductively</em>, such that:<ol type="1"><li><span class="math inline">\mathcal{P} \subseteq \text{Form}(\mathcal{P})</span>,<li>If <span class="math inline">F \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">\neg F \in \text{Form}(\mathcal{P})</span>,<li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \land G) \text{Form}(\mathcal{P})</span></ol><blockquote><p>This definition of formulas until here suffice as we can define other operators from <span class="math inline">\neg</span> and <span class="math inline">\land</span>. Indeed, we will sometimes use only these when proving theorems (or even defining concepts). In practice, we also further assume:</blockquote><ol start="4" type="1"><li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \lor G) \in \text{Form}(\mathcal{P})</span><li>If <span class="math inline">F, G \in \text{Form}(\mathcal{P})</span>, then <span class="math inline">(F \to G) \in \text{Form}(\mathcal{P})</span></ol><blockquote><p>With just the NAND operator <span class="math inline">\bar{\land}</span> alone, it is possible to build other logical operators, so that (2)-(3) can be reduced to single statement with NAND.</blockquote><p>When we refer an object <span class="math inline">F</span> as a (propositional) <strong>formula</strong>, we simply mean it is an element of <span class="math inline">\text{Form}(\mathcal{P})</span> for some set of atomic variables <span class="math inline">\mathcal{P}</span>.<p>Sometimes, we will omit the use of brackets for readibility, so that, for example, <span class="math inline">A \land B</span> should be understood as the formula <span class="math inline">(A \land B)</span>.<h2 id="def.-syntactic-identity">Def. Syntactic Identity</h2><p>With <span class="math inline">=</span>, we will denote the <strong>syntactic identity</strong>. That is, if <span class="math inline">F</span> and <span class="math inline">G</span> are strings and are formulas, then <span class="math inline">F=G</span> will simply denote they are strings of symbols of same lenght with same symbols in each place. Notice that this is a <em>semantic defintion</em> for our syntactic model.<h2 id="def.-operators">Def. Operators</h2><p>Given the logical operators <span class="math inline">\neg</span> and <span class="math inline">\land</span> and the atomic variable <span class="math inline">\bot</span>, we can <em>define</em>, for formulas <span class="math inline">F</span> and <span class="math inline">G</span><ul><li><span class="math inline">\top \triangleq \neg \bot</span>,<li><span class="math inline">(F \lor G) \triangleq \neg (\neg F \land \neg G)</span>, and<li><span class="math inline">(F \to G) \triangleq (\neg F \lor Q)</span></ul><blockquote><p>Notice that we have just defined syntactic abbreviation, didn’t prove anything.</blockquote><h2 id="def.-subformula">Def. Subformula</h2><p>Let <span class="math inline">F \in \text{Form}(\mathcal{P})</span> be a formula. Then the set <span class="math inline">\text{Sub}(F)</span> of <strong>subformulas</strong> of <span class="math inline">F</span> is the smallest set, such that<ul><li><span class="math inline">F \in \text{Sub}(F)</span>,<li>If <span class="math inline">F = \neg G</span>, then <span class="math inline">G \in \text{Sub}(F)</span>.<li>If <span class="math inline">F = (G \land H)</span>, then <span class="math inline">G,H \in \text{Sub}(F)</span>.</ul><blockquote><p>Here, we have just defined subformula for (1)-(3) above, it should be clear what a subformula is for an extended definition.</blockquote><p>The set <span class="math inline">\text{Sub}^+(F)</span> of <strong>proper subformulas</strong> is defined as <span class="math inline">\text{Sub}(F) \setminus \{F\}</span>.<h2 id="thm.-principle-of-induction-on-formulas">Thm. Principle of Induction on Formulas</h2><p>Since we are going to use induction heavily, we will prove that if <span class="math inline">\phi</span> is any property which<ol type="1"><li>Holds for all atomic formulas,<li>If holds for <span class="math inline">F</span>, it also holds for <span class="math inline">\neg F</span>, and<li>If holds for <span class="math inline">F</span> and <span class="math inline">G</span>, it also holds for <span class="math inline">(F \land G)</span>,</ol><p>Then <span class="math inline">\phi</span> holds for all formulas (of propositional logic).<details><summary><b>Proof</b></summary><p><br><blockquote><p>TODO:</blockquote></details><h2 id="def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</h2><p>A finite sequence <span class="math inline">(F_0, ..., F_n)</span> is called a <strong>formation sequence</strong> for the formula <span class="math inline">F</span> if <span class="math inline">F = F_n</span> and for all <span class="math inline">i \leq n</span>, either<ol type="1"><li><span class="math inline">F_i</span> is atomic formula, or<li>there exists <span class="math inline">j,k \lt i</span> such that, either<ol type="1"><li><span class="math inline">F_i = \neg F_j</span>,<li><span class="math inline">F_i = (F_j \land F_k)</span>.</ol></ol><h3 id="example">Example</h3><p>For example, for atomics <span class="math inline">p_0, p_1, p_2 \in \mathcal{P}</span> the sequence<p><span class="math display">(p_0, p_1, (p_1 \land p_0), \neg (p_1 \land p_0))</span><p>is a formation sequence for <span class="math inline">\neg (p_1 \land p_0)</span>, as is<p><span class="math display">(p_0, p_1, p_0,(p_1 \land p_0), (p_0 \land p_1), \neg (p_1 \land p_0))</span><h3 id="thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</h3><p>Every propositional formula has a formation sequence.<h2 id="def.-valuation">Def. Valuation</h2><p>Given a set <span class="math inline">\mathcal{P}</span> of atomic variables, a <strong>valuation</strong> (or <strong>assignment</strong>) <span class="math inline">v</span> is a function<p><span class="math display">v: \mathcal{P} \to \mathcal{V} = \{\mathbb{T}, \mathbb{F}\}</span><p>which simply assigns semantic <strong>true</strong> or <strong>false</strong> to atomic variables.<p>So from now on, depending on context, we may assume <span class="math inline">\bot \in \mathcal{P}</span> and always define <span class="math inline">v(\bot) = \mathbb{F}</span>, thus <span class="math inline">v(\top) = \mathbb{T}</span>.<blockquote><p>Ponder what would happen if it were the case that <span class="math inline">\mathcal{V} = [0,1]</span> where <span class="math inline">\mathbb{F} = 0 \in \R</span> and <span class="math inline">\mathbb{T}=1</span>. Obviously, most of our definitions and theorems wouldn’t make sense in this setting.</blockquote><h2 id="def.-evaluation">Def. Evaluation</h2><p>Let <span class="math inline">F</span> be a formula and <span class="math inline">v</span> some valuation. We will abuse notation and also use <span class="math inline">v(F)</span> for the <strong>evaluation</strong> of a formula <span class="math inline">F</span>, defined naturally.<p>If <span class="math inline">v(F) = \mathbb{T}</span>, then we say <span class="math inline">v</span> <strong>models</strong> <span class="math inline">F</span> denoted by <span class="math inline">v \models F</span>. Equivalently, we say <span class="math inline">F</span> <strong>holds</strong> under <span class="math inline">v</span>.<blockquote><p>Notice that this is the first time we have defined the sign <span class="math inline">\models</span>.</blockquote><h2 id="def.-satisfiability">Def. Satisfiability</h2><p>A formula <span class="math inline">F</span> is said to be <strong>satisfiable</strong> if there exists an valuation <span class="math inline">v</span> such that <span class="math inline">v \models F</span>. Otherwise, it is called <strong>unsatisfiable</strong>.<h2 id="def.-tautology-and-contradiction">Def. Tautology and Contradiction</h2><ul><li>A formula <span class="math inline">F</span> is said to be a <strong>tautology</strong> if it holds under all valuations. This is denoted by <span class="math inline">\models F</span>.<li>Similarly, a formula is said to be a <strong>contradiction</strong> if it holds under no valuation. Denoted <span class="math inline">\not \models F</span><li>A formula which is satisfiable but not a tautology is called <strong>contingent</strong>.</ul><h2 id="def.-entails">Def. Entails</h2><p>We say a formula <span class="math inline">F</span> <strong>entails</strong> the formula <span class="math inline">G</span> denoted by <span class="math inline">F \models G</span> if every valuation which models <span class="math inline">F</span> also models <span class="math inline">G</span>. In this case, we also say <span class="math inline">G</span> is a <strong>consequence</strong> of <span class="math inline">F</span>.<blockquote><p>Notice how we are <strong>overloading</strong> (and will keep on overloading) the infix notation <span class="math inline">\models</span> with valuations, formulas etc. So the elements left or right handside of “models” sign is context-dependent.</blockquote><h2 id="def.-semantic-equivalence">Def. Semantic Equivalence</h2><p>Let <span class="math inline">F</span> and <span class="math inline">G</span> be formulas. If they entail each other, then we say they are <strong>equivalent</strong>. This is denoted by <span class="math inline">F \equiv G</span>.<h3 id="exercise">Exercise</h3><p><span class="math inline">(F \land G) \equiv (G \land F)</span><h3 id="exercise-distributivity-rules">Exercise (Distributivity Rules)</h3><ul><li><span class="math inline">(F \land (G \lor H)) \equiv ((F \land G) \lor (F \land H))</span><li><span class="math inline">(F \lor (G \land H)) \equiv ((F \lor G) \land (F \lor H))</span></ul><h2 id="def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</h2><p>From now on, when we say <span class="math inline">\Gamma</span> is <strong>a set of formulas</strong>, we will mean <span class="math inline">\Gamma \subseteq \text{Form}(\mathcal{P})</span>. So it is not <em>the</em> set of formulas, but rather <em>a</em> set of formulas.<blockquote><p>We will make use of the letters such as <span class="math inline">\Gamma, \Delta</span> to usually denote a set of formulas and uppercase latin letters <span class="math inline">A, B, F, G, ...</span> et cetera to denote formulas.</blockquote><p>Moreover, we’ll overload the <span class="math inline">\models</span> notation further in respect to this notion. Let <span class="math inline">\Gamma</span> be a set for formulas such that <span class="math inline">\Gamma = \Set{F_0, F_1, ...}</span>, then we say<ul><li>a valuation <span class="math inline">v</span> <strong>models</strong> <span class="math inline">\Gamma</span> denoted by <span class="math inline">v \models \Gamma</span> if <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>,<li><span class="math inline">\Gamma</span> <strong>entails</strong> (a formula) <span class="math inline">G</span> denoted by <span class="math inline">\Gamma \models G</span> if for every valuation <span class="math inline">v</span> such that <span class="math inline">v \models \Gamma</span> implies <span class="math inline">v \models G</span>,<li><span class="math inline">\Gamma</span> is <strong>satisfiable</strong> if there exists a valution <span class="math inline">v</span> such that <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>, and <strong>unsatisfiable</strong> otherwise.</ul><p>Now, let’s look at some basic semantic properties of propositional logic.<h3 id="thm.-semantic-modus-ponens">Thm. <em>Semantic</em> Modus Ponens</h3><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">A, B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Gamma \models (A \to B)</span>, then <span class="math inline">\Gamma \models B</span>.<h3 id="thm.">Thm. ?</h3><p>Let <span class="math inline">\Gamma</span> be a set of formulas. If <span class="math inline">\Delta</span> is satisfiable, then so is every finite subset of it.<h3 id="thm.-semantic-monotonicity">Thm. <em>Semantic</em> Monotonicity</h3><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas such that <span class="math inline">\Gamma \subseteq \Delta</span> and <span class="math inline">A</span> a formula. If <span class="math inline">\Gamma \models A</span> then <span class="math inline">\Delta \models A</span>.<h3 id="thm.-semantic-transitivity">Thm. <em>Semantic</em> Transitivity</h3><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas and <span class="math inline">A,B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Delta \cup \{A\} \models B</span>, then <span class="math inline">\Gamma \cup \Delta \models B</span>.<h2 id="thm.-semantic-deduction-theorem">Thm. <em>Semantic</em> Deduction Theorem</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">A</span> a formula. Then, <span class="math inline">\Gamma \models A</span> if and only if <span class="math inline">\Gamma \cup \{\neg A\}</span> is unsatisfiable.<h1 id="derivations">Derivations</h1><p>In this section we will define <span class="math inline">\vdash</span> notation called the <em>derives</em> which is pretty similar to <span class="math inline">\models</span> except <em>models</em> was being used semantically whereas <span class="math inline">\vdash</span> will be used syntatically. More precisely,<p>We want to formally define a syntactic model such that given a set of assumptions (or axioms; whatever they are) we want to <em>derive</em> (reach) further truths (of the model) based on these assumptions. Of course, those truths of our model should also somehow correspond to truths in our metamodel (or metalanguage). It wouldn’t really make sense otherwise. So, all it takes is to blindly follow the syntactic rules of our syntactic model to reach our semantic truths. In essence, that is what a <strong>derivation system</strong> is. We <em>derive</em> further truths from assumptions (which we usually assume to be the truth) with syntactic wizardry.<p>With <span class="math inline">\models</span> we were able to keep track of entailment. That is, given a set of formulas <span class="math inline">\Delta</span>, we said <span class="math inline">\Delta</span> <em>entails</em> <span class="math inline">F</span> written as <span class="math inline">\Delta \models F</span>. It simply meant that for each valuation which holds for the set <span class="math inline">\Delta</span> also holds for <span class="math inline">F</span>. In a nutshell, here (within our metalanguage) we are just saying <span class="math inline">\Delta</span> implies the formula <span class="math inline">F</span> (whatever a formula is) since each valuation which is <em>true</em> for <span class="math inline">\Delta</span> is also <em>true</em> for <span class="math inline">F</span>. Philosophically, we gave the meaning of being true in a form of boolean truths. We will further explore this concept later on.<p>In propositional logic, with <span class="math inline">\vdash</span> we want to do something similar, but syntatically. From a set of formulas <span class="math inline">\Delta</span> we want to be able to arrive <em>true</em> formulas <span class="math inline">F</span> such that they are also (correspondingly) true in our metatheory.<h2 id="def.-derives">Def. Derives</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">F, G</span>, and <span class="math inline">H</span> formulas. Then we <em>define</em> (for our propositional logic model) the <strong>derives</strong> operator <span class="math inline">\vdash</span> by the (basic) <strong>rules of derivations</strong> which are<p><span class="math display">\def\arraystretch{1.25} \begin{array}{llll} \text{Premise} &amp;&amp; \text{Conclusion} &amp; \text{Name} \\ \hline G \in \Gamma &amp;&amp; \Gamma \vdash G &amp; \text{Assumption} \\ \Gamma \vdash G \text{ and } \Gamma \subseteq \Delta &amp;&amp; \Delta \vdash G &amp; \text{Monotonicity} \\ \Gamma \vdash G &amp;&amp; \Gamma \vdash \neg \neg G &amp; \neg\neg\text{-Introduction} \\ \Gamma \vdash F \text{ and } \Gamma \vdash G &amp;&amp; \Gamma \vdash (F \land G) &amp; \land\text{-Introduction} \\ \Gamma \vdash (F \land G) &amp;&amp; \Gamma \vdash F &amp; \land\text{-Elimination} \\ \end{array}</span><p>We can extend these rules of derivations in any way we want (as long as it makes sense which we will define later), for example to include <span class="math inline">\lor</span> and <span class="math inline">\to</span>.<h2 id="def.-syntactic-proof">Def. Syntactic Proof</h2><p>A <strong>syntactic proof</strong> (sometimes called <strong>formal proof</strong>, or simply a <strong>proof</strong> if not to be confused with a proof in our metalanguage) in propositional logic is a finite <em>sequence</em> of statements of the form <span class="math inline">\Gamma \vdash F</span> where <span class="math inline">\Gamma</span> is a set of formulas and <span class="math inline">F</span> is a formula.<blockquote><p>Notice how a syntactic proof is our “witness” to the claim that <span class="math inline">F</span> is derivable (in our model) from <span class="math inline">\Delta</span> by following some syntactic rules.</blockquote><p>We say <span class="math inline">F</span> can be <strong>derived</strong> from <span class="math inline">\Gamma</span> if there exists a formal proof with the final step <span class="math inline">\Gamma \vdash F</span>.<h3 id="example-1">Example</h3><p>Let <span class="math inline">\Gamma = \Set{(\neg F \lor G)}</span> and derive <span class="math inline">F \to G</span> from <span class="math inline">\Gamma</span>.<details><summary><b>Solution</b></summary><p><br></p><span class="math display">\begin{array}{ll:l} \Gamma \cup \{F\} &amp; \vdash F &amp; \text{Assumption} \\ \Gamma \cup \{F\} &amp; \vdash (\neg F \lor G) &amp; \text{Assumption} \\ \Gamma \cup \{F\} &amp; \vdash (F \to G) &amp; (F \to G) \triangleq (\neg F \lor Q) \\ \Gamma \cup \{F\} &amp; \vdash G &amp; \text{Modus Ponens} \\ \Gamma &amp; \vdash (F \to G) &amp; \text{Modus Ponens} \\ \end{array}</span></details>