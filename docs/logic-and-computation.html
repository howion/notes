<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><meta charset="utf-8"><link href="https://www.howion.com/favicon.svg" rel="icon" type="image/svg+xml"><meta name="generator" content="pandoc"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes"><title>Logic and Computation</title><style>html{color:#1a1a1a;background-color:#fdfdfd}body{margin:0 auto;max-width:36em;padding-left:50px;padding-right:50px;padding-top:50px;padding-bottom:50px;hyphens:auto;overflow-wrap:break-word;text-rendering:optimizeLegibility;font-kerning:normal}@media (max-width:600px){body{font-size:.9em;padding:12px}h1{font-size:1.8em}}@media print{html{background-color:#fff}body{background-color:transparent;color:#000;font-size:12pt}h2,h3,p{orphans:3;widows:3}h2,h3,h4{page-break-after:avoid}}p{margin:1em 0}a{color:#1a1a1a}a:visited{color:#1a1a1a}img{max-width:100%}svg{height:auto;max-width:100%}h1,h2,h3,h4,h5,h6{margin-top:1.4em}h5,h6{font-size:1em;font-style:italic}h6{font-weight:400}ol,ul{padding-left:1.7em;margin-top:1em}li>ol,li>ul{margin-top:0}blockquote{margin:1em 0 1em 1.7em;padding-left:1em;border-left:2px solid #e6e6e6;color:#606060}code{font-family:Menlo,Monaco,Consolas,'Lucida Console',monospace;font-size:85%;margin:0;hyphens:manual}pre{margin:1em 0;overflow:auto}pre code{padding:0;overflow:visible;overflow-wrap:normal}.sourceCode{background-color:transparent;overflow:visible}hr{border:none;border-top:1px solid #1a1a1a;height:1px;margin:1em 0}table{margin:1em 0;border-collapse:collapse;width:100%;overflow-x:auto;display:block;font-variant-numeric:lining-nums tabular-nums}table caption{margin-bottom:.75em}tbody{margin-top:.5em;border-top:1px solid #1a1a1a;border-bottom:1px solid #1a1a1a}th{border-top:1px solid #1a1a1a;padding:.25em .5em .25em .5em}td{padding:.125em .5em .25em .5em}header{margin-bottom:4em;text-align:center}#TOC li{list-style:none}#TOC ul{padding-left:1.3em}#TOC>ul{padding-left:0}#TOC a:not(:hover){text-decoration:none}code{white-space:pre-wrap}span.smallcaps{font-variant:small-caps}div.columns{display:flex;gap:min(4vw,1.5em)}div.column{flex:auto;overflow-x:auto}div.hanging-indent{margin-left:1.5em;text-indent:-1.5em}ul.task-list[class]{list-style:none}ul.task-list li input[type=checkbox]{font-size:inherit;width:.8em;margin:0 .8em .2em -1.6em;vertical-align:middle}</style><style>@import url(https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap);html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility}svg{shape-rendering:geometricPrecision;text-rendering:geometricPrecision}a,h1,h2,h3,h4,h5,h6,img,p{box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-font-smoothing:inherit;-moz-osx-font-smoothing:inherit;backface-visibility:hidden;transform:translateZ(0);user-drag:none}img{display:block;max-width:100%;image-rendering:crisp-edges;image-rendering:pixelated;-webkit-touch-callout:none;-webkit-user-drag:none;user-select:none}*{border-collapse:inherit}*,:after,:before{box-sizing:inherit}svg{display:inline-block;fill:currentColor}a,button{-webkit-tap-highlight-color:transparent}:where(code,kbd,samp,pre){font-size:1em}canvas,picture,svg,video{max-width:100%;display:block}:where(article,aside,details,figcaption,figure,footer,header,main,menu,nav,section){display:block}a{text-decoration:none}a:hover{text-decoration:underline}.toc a{color:#ffffe3}.toc a:visited{color:#ffffe3}.content a{color:#0af}.content a:visited{color:#0af}html{margin:0;padding:0;padding-bottom:4em;background-color:#10100e;color:#ffffe3!important}body{padding:0 24px;margin:0 auto;max-width:912px;font-size:16px;font-family:Inter,sans-serif;font-optical-sizing:auto;font-weight:400;font-style:normal;line-height:1.5}blockquote{background-color:transparent;border-left:2.5px solid #ffffe3;padding:0 .25em 0 1em;margin:0 0 1em 0;opacity:.5;color:inherit}h1{font-size:4em;line-height:1.25;margin-top:1.5em;margin-bottom:.25em}p{line-height:1.5}h1:first-child{margin-top:.5em}h2{border-bottom:2px solid #ffffe3;padding-bottom:.25em;margin-top:1.5em}h1{break-before:page}h2,h3,h4,h5,h6{break-before:auto}details>p>br{display:none!important}details>summary{color:#ffffe3;cursor:pointer}details{margin-top:2em!important;color:rgba(255,255,227,.5)}nav{margin-top:2em;color:inherit}nav>ul>li>a{opacity:1}nav a{color:inherit;opacity:.5}nav>ul>li{margin-top:1em}nav>ul>li>a{font-weight:600}::selection{background-color:#ffffe3;color:#10100e}.katex,.katex .katex-html,.katex .katex-mathml{line-height:1.5;vertical-align:baseline}.katex{display:inline}.katex .katex-html{display:inline}@media print{.katex{transform:scale(1);transform-origin:left baseline}html{background-color:#fff!important;color:#000!important}h1{margin-top:.25em!important}h2{border-color:#000!important}.toc a{color:#000}.toc a:visited{color:#000!important}details{color:rgba(0,0,0,.5)!important}details>summary{color:#000!important}blockquote{border-color:rgba(0,0,0,.5)!important}}</style><style id="page_style">@page{margin:0;padding:.325in .325in;size:10in 13in}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css" integrity="sha384-WcoG4HRXMzYzfCgiyfrySxx90XSl2rxY5mnVY5TwtWE6KLrArNKn0T/mOgNL0Mmi" crossorigin="anonymous"><script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.js" integrity="sha384-J+9dG2KMoiR9hqcFao0IBLwxt6zpcyN68IgwzsCSkbreXUjmNVRhPFTssqdSGjwQ" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded",function(){const t={displayMode:!1,throwOnError:!1,macros:[],fleqn:!1};function e(e){if("SPAN"!==e.tagName)return;const n=e.classList.contains("display"),o=e.firstChild,l=Object.assign({},t);l.displayMode=n;return katex.renderToString(o.textContent,l)}const n=document.querySelectorAll(".math"),o=n.length;let l=0;function s(t){const a=Math.min(l+50,o);for(;l<a;l++){const t=n[l];t.innerHTML=e(t)}l<o&&("function"==typeof requestIdleCallback?requestIdleCallback(s,{timeout:1e3}):setTimeout(s,0))}"function"==typeof requestIdleCallback?requestIdleCallback(s,{timeout:1e3}):setTimeout(s,0)})</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js" integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script><h1>Table of Contents</h1><nav class="toc" role="doc-toc"><ul><li><a href="#logic-and-computation" id="toc-logic-and-computation">Logic and Computation</a><ul><li><a href="#introduction" id="toc-introduction">Introduction</a><li><a href="#resources" id="toc-resources">Resources</a><li><a href="#notation" id="toc-notation">Notation</a></ul><li><a href="#propositional-logic" id="toc-propositional-logic">10. Propositional Logic</a><ul><li><a href="#syntax-and-semantics" id="toc-syntax-and-semantics">Syntax and Semantics</a><li><a href="#notation.-truth" id="toc-notation.-truth">Notation. Truth</a><li><a href="#def.-alphabets-and-words" id="toc-def.-alphabets-and-words">Def. Alphabets and Words</a><li><a href="#def.-language-and-syntax" id="toc-def.-language-and-syntax">Def. Language and Syntax</a><li><a href="#thm.-cardinality-of-sigma" id="toc-thm.-cardinality-of-sigma">Thm. Cardinality of <span class="math inline">\Sigma^*</span></a><li><a href="#def.-propositional-formulas" id="toc-def.-propositional-formulas">Def. Propositional Formulas</a><li><a href="#def.-syntactic-identity" id="toc-def.-syntactic-identity">Def. Syntactic Identity</a><li><a href="#notation.-operators" id="toc-notation.-operators">Notation. Operators</a><li><a href="#def.-subformula" id="toc-def.-subformula">Def. Subformula</a><li><a href="#thm.-principle-of-induction-on-propositional-formulas" id="toc-thm.-principle-of-induction-on-propositional-formulas">Thm. Principle of Induction on Propositional Formulas</a><li><a href="#def.-formation-sequence-for-propositional-formulas" id="toc-def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</a><ul><li><a href="#example" id="toc-example">Example</a><li><a href="#thm.-existence-of-formation-sequence" id="toc-thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</a></ul><li><a href="#def.-valuation" id="toc-def.-valuation">Def. Valuation</a><li><a href="#def.-evaluation" id="toc-def.-evaluation">Def. Evaluation</a><li><a href="#def.-satisfiability" id="toc-def.-satisfiability">Def. Satisfiability</a><li><a href="#def.-tautology-and-contradiction" id="toc-def.-tautology-and-contradiction">Def. Tautology and Contradiction</a><li><a href="#def.-entails" id="toc-def.-entails">Def. Entails</a><li><a href="#def.-semantic-equivalence" id="toc-def.-semantic-equivalence">Def. Semantic Equivalence</a><ul><li><a href="#exercise-1.-symmetry-of-land" id="toc-exercise-1.-symmetry-of-land">Exercise 1. Symmetry of <span class="math inline">\land</span></a><li><a href="#exercise-2.-distributivity-rules" id="toc-exercise-2.-distributivity-rules">Exercise 2. Distributivity Rules</a><li><a href="#exercise-3.-de-morgans-rules" id="toc-exercise-3.-de-morgans-rules">Exercise 3. De Morgan’s Rules</a></ul><li><a href="#def.-a-set-of-formulas" id="toc-def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</a><li><a href="#thm.-semantic-modus-ponens" id="toc-thm.-semantic-modus-ponens">Thm. Semantic Modus Ponens</a><li><a href="#thm.-compactness-1" id="toc-thm.-compactness-1">Thm. Compactness (1)</a><li><a href="#thm.-semantic-monotonicity" id="toc-thm.-semantic-monotonicity">Thm. Semantic Monotonicity</a><li><a href="#thm.-semantic-transitivity" id="toc-thm.-semantic-transitivity">Thm. Semantic Transitivity</a><li><a href="#thm.-semantic-deduction-theorem" id="toc-thm.-semantic-deduction-theorem">Thm. Semantic Deduction Theorem</a></ul><li><a href="#propositional-derivations" id="toc-propositional-derivations">20. Propositional Derivations</a><ul><li><a href="#def.-derives" id="toc-def.-derives">Def. Derives</a><li><a href="#def.-syntactic-proof" id="toc-def.-syntactic-proof">Def. Syntactic Proof</a><ul><li><a href="#example-1" id="toc-example-1">Example</a></ul><li><a href="#thm.-soundness" id="toc-thm.-soundness">Thm. Soundness</a><li><a href="#def.-literal" id="toc-def.-literal">Def. Literal</a><li><a href="#def.-conjuctive-normal-form" id="toc-def.-conjuctive-normal-form">Def. Conjuctive Normal Form</a><li><a href="#def.-disjunctive-normal-form" id="toc-def.-disjunctive-normal-form">Def. Disjunctive Normal Form</a><li><a href="#thm.-cnf-and-dnf-duality" id="toc-thm.-cnf-and-dnf-duality">Thm. CNF and DNF Duality</a><li><a href="#thm.-generality-of-cnf-and-dnf" id="toc-thm.-generality-of-cnf-and-dnf">Thm. Generality of CNF and DNF</a><li><a href="#def.-horn-formula" id="toc-def.-horn-formula">Def. Horn Formula</a><li><a href="#thm.-hornsat" id="toc-thm.-hornsat">Thm. HORNSAT</a><li><a href="#to-dos" id="toc-to-dos">To-Do’s</a></ul><li><a href="#first-order-logic" id="toc-first-order-logic">30. First-Order Logic</a><ul><li><a href="#def.-alphabet" id="toc-def.-alphabet">Def. Alphabet</a><li><a href="#def.-term" id="toc-def.-term">Def. Term</a><li><a href="#def.-textvart" id="toc-def.-textvart">Def. <span class="math inline">\text{var}(t)</span></a><li><a href="#def.-formula" id="toc-def.-formula">Def. Formula</a><li><a href="#def.-textsubvarphi" id="toc-def.-textsubvarphi">Def. <span class="math inline">\text{sub}(\varphi)</span></a><li><a href="#def.-textfreevarphi" id="toc-def.-textfreevarphi">Def. <span class="math inline">\text{free}(\varphi)</span></a><li><a href="#notation.-first-order-logic" id="toc-notation.-first-order-logic">Notation. First-Order Logic</a><li><a href="#def.-textfreevarphi-1" id="toc-def.-textfreevarphi-1">Def. <span class="math inline">\text{free}(\varphi)</span></a><li><a href="#def.-sentence" id="toc-def.-sentence">Def. Sentence</a><li><a href="#to-dos-1" id="toc-to-dos-1">To-Do’s</a></ul><li><a href="#structures" id="toc-structures">40. Structures</a><ul><li><a href="#def.-structure" id="toc-def.-structure">Def. Structure</a><li><a href="#def.-valuation-1" id="toc-def.-valuation-1">Def. Valuation</a><li><a href="#def.-interpretation" id="toc-def.-interpretation">Def. Interpretation</a><li><a href="#notation.-model" id="toc-notation.-model">Notation. Model</a><li><a href="#def.-entails-1" id="toc-def.-entails-1">Def. Entails</a><li><a href="#def.-valid" id="toc-def.-valid">Def. Valid</a><li><a href="#def.-satisfiable" id="toc-def.-satisfiable">Def. Satisfiable</a></ul></ul></nav><div class="content"><h1 id="logic-and-computation">Logic and Computation</h1><h2 id="introduction">Introduction</h2><p>Superficial knowledge of computational complexity theory is assumed. You should be familiar with concepts such as PTIME, EXPSPACE etc.<p>Other than that, notes should be mostly self-sufficent for someone with the knowledge of at least basic set theory and simple combinatorics.<p>Due to nature of these notes we will mostly work in second-order ordinary set-theoric logic.<blockquote><p><strong>TODO.</strong> Add appendix for these prerequisites to superficially define them, or redirect to my or to online other resources.</blockquote><h2 id="resources">Resources</h2><ul><li><a href="https://github.com/OpenLogicProject/OpenLogic"><strong>The Open Logic Text</strong></a>, by various contributors<li><strong>A First Course in Logic: An Introduction to Model Theory, Proof Theory, Computability and Complexity</strong> by Shawn Hedman<li><strong>Mathematical Logic</strong>, 2nd Ed., by H.-D. Ebbinghaus, J. Flum, W. Thomas<li><strong>A Concise Introduction to Mathematical Logic</strong>, 3rd Ed., by Wolfgang Rautenberg</ul><h2 id="notation">Notation</h2><ul><li><span class="math inline">0 \in \N</span> and <span class="math inline">\N^+ :=\ \N \setminus \{0\}</span>.<li><span class="math inline">\varnothing</span> denotes the empty set.<li>Cardinality of a set <span class="math inline">S</span> is denoted with <span class="math inline">|S|</span>.</ul><!-- ## Def. Collection

        Generally speaking, when it is said that $X$ is a **collection** it usually considered to be a set or a proper class.

        In these notes, when we say **collection** or **set**, we will mean any set of any cardinality since we are working in an ordinary set-theoric foundation. If your underlying meta-theory is stronger, say NBG/GB, you may also allow a collection to be a proper class.

        For this reason, when we say $S$ is a **subset** of a collection $X$, we actually mean $S$ is a **subclass** of $X$. --><h1 id="propositional-logic">10. Propositional Logic</h1><h2 id="syntax-and-semantics">Syntax and Semantics</h2><p>Theorems and definitions we prove and define here are actually meta-theorems and meta-definitions in our meta-language. Note that we haven’t yet shown propositional logic (which is also called <strong>zeroth-order logic</strong>) is a subset of our meta-language. It is just, kind of, nonsense syntax at this moment.<h2 id="notation.-truth">Notation. Truth</h2><p>Syntactically, we will use the symbols<ul><li><span class="math inline">\bot</span> called <strong>bottom</strong> or simply <strong>bot</strong> to denote falsity <em>in our syntactic model</em>,<li><span class="math inline">\top</span> called <strong>top</strong> to denote truth <em>in our syntactic model</em>,<li><span class="math inline">\neg</span> called <strong>negation</strong> to denote <em>negation</em>,<li><span class="math inline">\to</span> called <strong>material implication</strong> to denote <em>implication</em>,<li><span class="math inline">\land</span> called <strong>conjuction</strong> to denote <em>and</em>, and<li><span class="math inline">\lor</span> called <strong>disjunction</strong> to denote <em>or</em>.</ul><p>Semantically, we will use the symbols<ul><li><span class="math inline">\mathbb{T}</span> called <strong>true</strong> to denote <em>semantic truth</em>, and<li><span class="math inline">\mathbb{F}</span> called <strong>false</strong> to denote <em>semantic falsity</em>.<li><span class="math inline">:=</span> called <strong>defined as</strong> to denote <em>semantic equality</em>.</ul><h2 id="def.-alphabets-and-words">Def. Alphabets and Words</h2><p>By an <strong>alphabet</strong> <span class="math inline">\Sigma</span> we mean a non-empty set of <strong>symbols</strong> (or <strong>letters</strong>).<p>A finite sequence of symbols over an alphabet <span class="math inline">\Sigma</span> is called a <strong>word</strong> (or a <strong>string</strong>). Moreover, <span class="math inline">\Sigma^*</span> denotes the set of all words and the <strong>length</strong> of a word <span class="math inline">w</span> is the number of letters (that is size of the finite sequence) denoted with <span class="math inline">|w|</span>. The <strong>empty word</strong> denoted with <span class="math inline">\epsilon</span> is <em>the</em> word of length <span class="math inline">0</span>.<h2 id="def.-language-and-syntax">Def. Language and Syntax</h2><p>Let <span class="math inline">\Sigma</span> be an alphabet. Any subset <span class="math inline">L</span> of <span class="math inline">\Sigma^*</span> is called a <strong>(formal) language</strong> over <span class="math inline">\Sigma</span>. Moreover, let<p><span class="math display">L = \Set{w \in \Sigma^* | \varphi(w)}</span><p>be a language and <span class="math inline">\varphi</span> be the definition of that language, then <span class="math inline">\varphi</span> is called the <strong>syntax</strong> of the language <span class="math inline">L</span>.<h2 id="thm.-cardinality-of-sigma">Thm. Cardinality of <span class="math inline">\Sigma^*</span></h2><p>Let the alphabet <span class="math inline">\Sigma</span> be at most countable, then the set <span class="math inline">\Sigma^*</span> of words over <span class="math inline">\Sigma</span> is countable.<h2 id="def.-propositional-formulas">Def. Propositional Formulas</h2><p>Let <span class="math inline">\mathcal{P}</span> be a, possibly empty, countable set called the <strong>atomic formulas</strong> (or <strong>prime formulas</strong>).<p>The set <span class="math inline">\mathcal{L}_0(\mathcal{P})</span> called the <strong>propositional formulas</strong> for the atomics <span class="math inline">\mathcal{P}</span> defined <em>inductively</em> as the <em>smallest set</em> such that:<ol type="1"><li><span class="math inline">\mathcal{P} \subseteq \mathcal{L}_0(\mathcal{P})</span>,<li>If <span class="math inline">F \in \mathcal{L}_0(\mathcal{P})</span>, then <span class="math inline">\neg F \in \mathcal{L}_0(\mathcal{P})</span>,<li>If <span class="math inline">F, G \in \mathcal{L}_0(\mathcal{P})</span>, then <span class="math inline">\land \&gt; F \&gt; G \in \mathcal{L}_0(\mathcal{P})</span>,</ol><blockquote><p>This definition of formulas until here suffice as we can define other operators from <span class="math inline">\neg</span> and <span class="math inline">\land</span>. Indeed, we will sometimes use only these when proving theorems (or even defining concepts).</blockquote><blockquote><p>With just the NAND operator, <span class="math inline">\bar{\land}</span>, alone, it is possible to build other logical operators, so that (2) and (3) can be reduced to <span class="math inline">\bar{\land} \&gt; F \&gt; G</span> and negation and logical and can be semantically defined via NAND.</blockquote><p>Notice that <span class="math inline">\mathcal{L}_0(\mathcal{P})</span> is a language over <span class="math inline">\Sigma = \mathcal{P} \cup \{\neg, \land \}</span> with the syntax given above where intersection of <span class="math inline">\mathcal{P}</span> and the logical connectives is empty.<p>When we refer an object <span class="math inline">F</span> as a <strong>propositional formula</strong>, we simply mean it is an element of <span class="math inline">\mathcal{L}_0(\mathcal{P})</span> for some set of atomic variables <span class="math inline">\mathcal{P}</span>.<p>With the use of <strong>Polish Notation</strong> here we have removed the need for parenthesis so that, for example, <span class="math inline">\land \neg \&gt; A \&gt; B</span> means <span class="math inline">(\neg A \land B)</span>. Since we know the arity of each operator, compositions of operators is also well-defined (exercise). But note that this notation, although this is the way we defined, is hard to follow for us mere humans, so we will mostly stick to our classical <strong>infix notation</strong> for the rest of the notes. Moreover, when using infix notation, we will omit the use of brackets for readibility when it is appropriate.<p>Finally, we will denote <strong>the propositional logic</strong> with <span class="math inline">\bot</span> as its only atomic formula with <span class="math inline">\mathcal{L}_0</span> that is <span class="math inline">\mathcal{L}_0 := \mathcal{L}_0(\{\bot\})</span>.<p>One could, of course, relax or even contradict these definitions, which is not uncommon in logic. What matters is the core intuition.<h2 id="def.-syntactic-identity">Def. Syntactic Identity</h2><p>With <span class="math inline">=</span>, we will denote the <strong>syntactic identity</strong>. That is, if <span class="math inline">F</span> and <span class="math inline">G</span> are strings and are formulas, then <span class="math inline">F=G</span> will simply denote they are strings of symbols of same lenght with same symbols in each place. Notice that this is a <em>semantic defintion</em> for our syntactic model.<h2 id="notation.-operators">Notation. Operators</h2><p>Given the logical operators <span class="math inline">\neg</span> and <span class="math inline">\land</span> and <em>the</em> atomic variable <span class="math inline">\bot</span>, we <em>define</em> for formulas <span class="math inline">F</span> and <span class="math inline">G</span><ul><li><span class="math inline">\top := \neg \bot</span>,<li><span class="math inline">\lor \&gt; F \&gt; G := \neg \land \neg F \&gt; \neg G</span>,<li><span class="math inline">\to F \&gt; G := \lor \neg F \&gt; G</span>, and<li><span class="math inline">\leftrightarrow F \&gt; G := \land \to F \&gt; G \to G \&gt; F</span></ul><blockquote><p>Notice that we have just defined some syntactic abbreviations, didn’t prove anything. Exercise and write these polish notational definitions in ordinary infix notation.</blockquote><h2 id="def.-subformula">Def. Subformula</h2><p>The <strong>subformula</strong> function <span class="math inline">\text{sub}</span> is defined on the language <span class="math inline">\mathcal{L}_0(\mathcal{P})</span> inductively as<p><span class="math display">\def\arraystretch{1.25} \begin{array}{rcl} \text{sub}(p) &amp;:=&amp; \{p\} \\ \text{sub}(\neg F) &amp;:=&amp; \{\neg F\} \cup \text{sub}(F) \\ \text{sub}(\land \&gt; F \&gt; G) &amp;:=&amp; \{\land \&gt; F \&gt; G\} \cup \text{sub}(F) \cup \text{sub}(G) \\ \end{array}</span><p>where <span class="math inline">p</span> is an atomic formula and <span class="math inline">F</span> is a formula in <span class="math inline">\mathcal{L}_0(\mathcal{P})</span>. Moreover, the <strong>proper subformula</strong> function <span class="math inline">\text{sub}^+</span> is defined as<p><span class="math display">\text{sub}^+ := \text{sub}(F) \setminus \{F\}</span><blockquote><p>Can you inductively define a function for atomics of a formula?</blockquote><h2 id="thm.-principle-of-induction-on-propositional-formulas">Thm. Principle of Induction on Propositional Formulas</h2><p>Since we are going to use induction heavily, we will prove that if <span class="math inline">\phi</span> is any property which<ol type="1"><li>Holds for all atomic formulas,<li>If holds for <span class="math inline">F</span>, it also holds for <span class="math inline">\neg F</span>, and<li>If holds for <span class="math inline">F</span> and <span class="math inline">G</span>, it also holds for <span class="math inline">\land \&gt; F \&gt; G</span>,</ol><p>Then <span class="math inline">\phi</span> holds for all formulas (of propositional logic).<details><summary><b>Proof</b></summary><p><br><blockquote><p>TODO:</blockquote></details><h2 id="def.-formation-sequence-for-propositional-formulas">Def. Formation Sequence for Propositional Formulas</h2><blockquote><p>Let’s stick to ordinary infix notation from now on until we define the syntax of first-order logic.</blockquote><p>A finite sequence <span class="math inline">(F_0, ..., F_n)</span> is called a <strong>formation sequence</strong> for the formula <span class="math inline">F</span> if <span class="math inline">F = F_n</span> and for all <span class="math inline">i \leq n</span>, either<ol type="1"><li><span class="math inline">F_i</span> is atomic formula, or<li>there exists <span class="math inline">j,k \lt i</span> such that, either<ol type="1"><li><span class="math inline">F_i = \neg F_j</span>,<li><span class="math inline">F_i = (F_j \land F_k)</span>.</ol></ol><h3 id="example">Example</h3><p>For example, for atomics <span class="math inline">p_0, p_1, p_2 \in \mathcal{P}</span> the sequence<p><span class="math display">(p_0, p_1, (p_1 \land p_0), \neg (p_1 \land p_0))</span><p>is a formation sequence for <span class="math inline">\neg (p_1 \land p_0)</span>, as is<p><span class="math display">(p_0, p_1, p_0,(p_1 \land p_0), (p_0 \land p_1), \neg (p_1 \land p_0))</span><h3 id="thm.-existence-of-formation-sequence">Thm. Existence of Formation Sequence</h3><p>Every propositional formula has a formation sequence.<h2 id="def.-valuation">Def. Valuation</h2><p>Given a set <span class="math inline">\mathcal{P}</span> of atomic variables, a <strong>valuation</strong> (or <strong>assignment</strong>) <span class="math inline">v</span> is a function<p><span class="math display">v: \mathcal{P} \to \mathcal{V} = \{\mathbb{T}, \mathbb{F}\}</span><p>which simply assigns semantic <strong>true</strong> or <strong>false</strong> to atomic variables.<p>So from now on, depending on context, we may assume <span class="math inline">\bot \in \mathcal{P}</span> and always define <span class="math inline">v(\bot) = \mathbb{F}</span>, thus <span class="math inline">v(\top) = \mathbb{T}</span>.<blockquote><p>Ponder what would happen if it were the case that <span class="math inline">\mathcal{V} = [0,1]</span> where <span class="math inline">\mathbb{F} = 0 \in \R</span> and <span class="math inline">\mathbb{T}=1</span>. Obviously, most of our definitions and theorems wouldn’t make sense in this setting.</blockquote><h2 id="def.-evaluation">Def. Evaluation</h2><p>Let <span class="math inline">F</span> be a formula and <span class="math inline">v</span> some valuation. We will abuse notation and also use <span class="math inline">v(F)</span> for the <strong>evaluation</strong> of a formula <span class="math inline">F</span>, defined naturally.<p>If <span class="math inline">v(F) = \mathbb{T}</span>, then we say <span class="math inline">v</span> <strong>models</strong> <span class="math inline">F</span> denoted by <span class="math inline">v \models F</span>. Equivalently, we say <span class="math inline">F</span> <strong>holds</strong> under <span class="math inline">v</span>.<blockquote><p>Notice that this is the first time we have defined the sign <span class="math inline">\models</span>.</blockquote><h2 id="def.-satisfiability">Def. Satisfiability</h2><p>A formula <span class="math inline">F</span> is said to be <strong>satisfiable</strong> if there exists an valuation <span class="math inline">v</span> such that <span class="math inline">v \models F</span>. Otherwise, it is called <strong>unsatisfiable</strong>.<h2 id="def.-tautology-and-contradiction">Def. Tautology and Contradiction</h2><ul><li>A formula <span class="math inline">F</span> is said to be a <strong>tautology</strong> if it holds under all valuations. This is denoted by <span class="math inline">\models F</span>.<li>Similarly, a formula is said to be a <strong>contradiction</strong> if it holds under no valuation, denoted by <span class="math inline">\not \models F</span>.<li>A formula which is satisfiable but not a tautology is called <strong>contingent</strong>.</ul><h2 id="def.-entails">Def. Entails</h2><p>We say a formula <span class="math inline">F</span> <strong>entails</strong> the formula <span class="math inline">G</span> denoted by <span class="math inline">F \models G</span> if every valuation which models <span class="math inline">F</span> also models <span class="math inline">G</span>. In this case, we also say <span class="math inline">G</span> is a <strong>consequence</strong> of <span class="math inline">F</span>.<blockquote><p>Notice how we are <strong>overloading</strong> (and will keep on overloading) the infix notation <span class="math inline">\models</span> with valuations, formulas etc. So the elements left or right handside of “models” sign is context-dependent.</blockquote><h2 id="def.-semantic-equivalence">Def. Semantic Equivalence</h2><p>Let <span class="math inline">F</span> and <span class="math inline">G</span> be formulas. If they entail each other, then we say they are <strong>equivalent</strong>. This is denoted by <span class="math inline">F \equiv G</span>.<h3 id="exercise-1.-symmetry-of-land">Exercise 1. Symmetry of <span class="math inline">\land</span></h3><p><span class="math inline">(F \land G) \equiv (G \land F)</span><h3 id="exercise-2.-distributivity-rules">Exercise 2. Distributivity Rules</h3><ul><li><span class="math inline">(F \land (G \lor H)) \equiv ((F \land G) \lor (F \land H))</span><li><span class="math inline">(F \lor (G \land H)) \equiv ((F \lor G) \land (F \lor H))</span></ul><h3 id="exercise-3.-de-morgans-rules">Exercise 3. De Morgan’s Rules</h3><ul><li><span class="math inline">\neg(F \land G) \equiv (\neg F \lor \neg G)</span><li><span class="math inline">\neg(F \lor G) \equiv (\neg F \land \neg G)</span></ul><h2 id="def.-a-set-of-formulas">Def. <em>A</em> Set of Formulas</h2><p>From now on, when we say <span class="math inline">\Gamma</span> is <strong>a set of formulas</strong>, we will mean <span class="math inline">\Gamma \subseteq \mathcal{L}_0(\mathcal{P})</span>. So it is not <em>the</em> set of formulas, but rather a set of formulas.<blockquote><p>We will make use of the letters such as <span class="math inline">\Gamma, \Delta</span> to usually denote a set of formulas and uppercase latin letters <span class="math inline">A, B, F, G, ...</span> et cetera to denote formulas.</blockquote><p>Moreover, we’ll overload the <span class="math inline">\models</span> notation further in respect to this notion. Let <span class="math inline">\Gamma</span> be a set for formulas such that <span class="math inline">\Gamma = \Set{F_0, F_1, ...}</span>, then we say<ul><li>a valuation <span class="math inline">v</span> <strong>models</strong> <span class="math inline">\Gamma</span> denoted by <span class="math inline">v \models \Gamma</span> if <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>,<li><span class="math inline">\Gamma</span> <strong>entails</strong> (a formula) <span class="math inline">G</span> denoted by <span class="math inline">\Gamma \models G</span> if for every valuation <span class="math inline">v</span> such that <span class="math inline">v \models \Gamma</span> implies <span class="math inline">v \models G</span>,<li><span class="math inline">\Gamma</span> is <strong>satisfiable</strong> if there exists a valution <span class="math inline">v</span> such that <span class="math inline">v \models F_i</span> for each <span class="math inline">i</span>, and <strong>unsatisfiable</strong> otherwise.</ul><p>Now, let’s look at some basic semantic properties of propositional logic.<h2 id="thm.-semantic-modus-ponens">Thm. Semantic Modus Ponens</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">A, B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Gamma \models (A \to B)</span>, then <span class="math inline">\Gamma \models B</span>.<h2 id="thm.-compactness-1">Thm. Compactness (1)</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas. If <span class="math inline">\Gamma</span> is satisfiable, then so is every finite subset of it.<blockquote><p>This is the easy (to prove) direction of what is called the <strong>compactness</strong> (of propositional logic), we will see the other direction is also true in the later sections.</blockquote><h2 id="thm.-semantic-monotonicity">Thm. Semantic Monotonicity</h2><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas such that <span class="math inline">\Gamma \subseteq \Delta</span> and <span class="math inline">F</span> a formula. If <span class="math inline">\Gamma \models F</span> then <span class="math inline">\Delta \models F</span>.<h2 id="thm.-semantic-transitivity">Thm. Semantic Transitivity</h2><p>Let <span class="math inline">\Gamma</span> and <span class="math inline">\Delta</span> be a set of formulas and <span class="math inline">A,B</span> formulas. If <span class="math inline">\Gamma \models A</span> and <span class="math inline">\Delta \cup \{A\} \models B</span>, then <span class="math inline">\Gamma \cup \Delta \models B</span>.<h2 id="thm.-semantic-deduction-theorem">Thm. Semantic Deduction Theorem</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">F</span> a formula. Then, <span class="math inline">\Gamma \models F</span> if and only if <span class="math inline">\Gamma \cup \{\neg F\}</span> is unsatisfiable.<h1 id="propositional-derivations">20. Propositional Derivations</h1><p>We want to formally define a syntactic model such that given a set of assumptions (or axioms; whatever they are) we want to <em>derive</em> (reach) further truths (of the model) based on these assumptions. Of course, those truths of our model should also somehow correspond to truths in our meta-model (or meta-language). It wouldn’t really make sense otherwise. So, all it takes is to blindly follow the syntactic rules of our syntactic model to reach our semantic truths. In essence, that is what a <strong>derivation system</strong> is. We <em>derive</em> further truths from assumptions (which we usually assume to be the truth) with syntactic wizardry.<p>In this section we will define <span class="math inline">\vdash</span> notation called the <em>derives</em> which is pretty similar to <span class="math inline">\models</span> except <em>models</em> was being used semantically whereas <span class="math inline">\vdash</span> will be used syntatically.<p>In propositional logic, with <span class="math inline">\models</span> we were able to keep track of entailment. That is, given a set of formulas <span class="math inline">\Delta</span>, we said <span class="math inline">\Delta</span> <em>entails</em> <span class="math inline">F</span> written as <span class="math inline">\Delta \models F</span>. It simply meant that for each valuation which holds for the set <span class="math inline">\Delta</span> also holds for <span class="math inline">F</span>. Philosophically, we gave the meaning of being true in the form of boolean truths. We will further explore this concept later on.<p>In propositional logic, with <span class="math inline">\vdash</span> we want to do something similar, but syntatically. From a set of formulas <span class="math inline">\Delta</span> we want to be able to arrive <em>true</em> formulas <span class="math inline">F</span> such that they are also (correspondingly) true in our meta-theory.<h2 id="def.-derives">Def. Derives</h2><p>Let <span class="math inline">\Gamma</span> be a set of formulas and <span class="math inline">F, G</span>, and <span class="math inline">H</span> formulas. Then we <em>define</em> (for our propositional logic model) the <strong>derives</strong> operator <span class="math inline">\vdash</span> by the (basic) <strong>rules of derivations</strong> which are<p><span class="math display">\def\arraystretch{1.25} \begin{array}{llll} \text{\small Premise} &amp;&amp; \text{\small Conclusion} &amp; \text{\small Name} \\ \hline G \in \Gamma &amp;&amp; \Gamma \vdash G &amp; \text{\small Assumption} \\ \Gamma \vdash G \text{ and } \Gamma \subseteq \Delta &amp;&amp; \Delta \vdash G &amp; \text{\small Monotonicity} \\ \Gamma \vdash G &amp;&amp; \Gamma \vdash \neg \neg G &amp; \text{\small Double }\neg \\ \Gamma \vdash F \text{ and } \Gamma \vdash G &amp;&amp; \Gamma \vdash (F \land G) &amp; \land\text{\small -Introduction} \\ \Gamma \vdash (F \land G) &amp;&amp; \Gamma \vdash F &amp; \land\text{\small -Elimination} \\ \Gamma \vdash (F \land G) &amp;&amp; \Gamma \vdash (G \land F) &amp; \land\text{\small -Symmetry} \\ \end{array}</span><blockquote><p>Note that, for brevity, we didn’t include the rules for brackets such that <span class="math inline">(F)</span> and <span class="math inline">F</span> are derived from each other etc.</blockquote><p>We can extend these rules of derivations in any way we want (as long as it makes sense which we will define later), for example to include <span class="math inline">\lor</span> and <span class="math inline">\to</span>.<p>We can also reduce these rules, indeed we only need 3 which is a topic of no concern in these notes.<h2 id="def.-syntactic-proof">Def. Syntactic Proof</h2><p>A <strong>syntactic proof</strong> (sometimes called <strong>formal proof</strong>, or simply a <strong>proof</strong> if not to be confused with a proof in our meta-language) in propositional logic is a finite <em>sequence</em> of statements of the form <span class="math inline">\Gamma \vdash F</span> where <span class="math inline">\Gamma</span> is a set of formulas and <span class="math inline">F</span> is a formula.<blockquote><p>Notice how a syntactic proof is our “witness” to the claim that <span class="math inline">F</span> is derivable (in our model) from <span class="math inline">\Delta</span> by following some syntactic rules.</blockquote><p>We say <span class="math inline">F</span> can be <strong>derived</strong> from <span class="math inline">\Gamma</span> if there exists a formal proof with the final step <span class="math inline">\Gamma \vdash F</span>.<h3 id="example-1">Example</h3><p>Let <span class="math inline">\Gamma = \Set{(\neg F \lor G)}</span> and derive <span class="math inline">F \to G</span> from <span class="math inline">\Gamma</span>.<details><summary><b>Solution</b></summary><p><br></p><span class="math display">\begin{array}{ll:l} \Gamma \cup \{F\} &amp; \vdash F &amp; \text{Assumption} \\ \Gamma \cup \{F\} &amp; \vdash (\neg F \lor G) &amp; \text{Assumption} \\ \Gamma \cup \{F\} &amp; \vdash (F \to G) &amp; (F \to G) \triangleq (\neg F \lor Q) \\ \Gamma \cup \{F\} &amp; \vdash G &amp; \text{Modus Ponens} \\ \Gamma &amp; \vdash (F \to G) &amp; \text{Modus Ponens} \\ \end{array}</span></details><h2 id="thm.-soundness">Thm. Soundness</h2><p>Let <span class="math inline">\Gamma</span> be a set of propositional formulas and <span class="math inline">F</span> a formula in propositional logic such that <span class="math inline">\Gamma \vdash F</span>, then <span class="math inline">\Gamma \models F</span>.<details><summary><b>Proof</b></summary><p><br><blockquote><p>TODO:</blockquote></details><p>Therefore<ul><li><span class="math inline">\vdash G</span> implies <span class="math inline">G</span> is a tautology,<li><span class="math inline">\vdash \neg G</span> implies <span class="math inline">G</span> is a contradiction.</ul><h2 id="def.-literal">Def. Literal</h2><p>A <strong>literal</strong> is either an atomic formula, or the negation of an atomic formula. The former is called a <strong>positive literal</strong> and the latter is called a <strong>negative literal</strong>.<h2 id="def.-conjuctive-normal-form">Def. Conjuctive Normal Form</h2><p>A propositional formula <span class="math inline">F</span> is in <strong>conjuctive normal form (CNF)</strong> if it is a conjuction of disjunctions of literals, that is<p><span class="math display">F = \bigwedge_{i = 1}^{n} \left(\bigvee_{j = 1}^{m} \right) L_{ij}</span><p>where <span class="math inline">m,n \in \N^+</span> and each <span class="math inline">L_{ij}</span> is a literal.<h2 id="def.-disjunctive-normal-form">Def. Disjunctive Normal Form</h2><p>A propositional formula <span class="math inline">F</span> is in <strong>disjunctive normal form (DNG)</strong> if it is a conjuction of disjunctions of literals, that is<p><span class="math display">F = \bigvee_{i = 1}^{n} \left(\bigwedge_{j = 1}^{m} \right) L_{ij}</span><p>where <span class="math inline">m,n \in \N^+</span> and each <span class="math inline">L_{ij}</span> is a literal.<h2 id="thm.-cnf-and-dnf-duality">Thm. CNF and DNF Duality</h2><p>Negation of a formula in DNF is equivalent to a formula in CNF. Similarly, negation of a formula in CNF is equivalent to a formula in DNF.<h2 id="thm.-generality-of-cnf-and-dnf">Thm. Generality of CNF and DNF</h2><p>Any propositional formula <span class="math inline">F</span> is equivalent to some formula <span class="math inline">F_\text{CNF}</span> in CNF and some formula <span class="math inline">F_\text{DNF}</span> in DNF.<p>The cannonical algorithms to build equivalent formulas in CNF and DNF are straightforward and simple. Curious reader may exercise or check out such algorithms.<h2 id="def.-horn-formula">Def. Horn Formula</h2><p>A propositional formula <span class="math inline">F</span> is a <strong>Horn formula</strong> if its in CNF and every disjunction contains at most one positive literal.<p>A Horn formula is called <strong>basic</strong> if it does not use any conjunction. Therefore, every Horn formula is a conjuction of basic Horn formulas.<p>Notice that, for example, the basic Horn formula <span class="math inline">\neg A_1 \lor \neg A_2 \lor \neg A_3 \lor A_4</span> is equivalent to <span class="math inline">(A_1 \land A_2 \land A_3) \to A_4</span>. Therefore, every Horn formula can be written as conjuction of implications. In the case that there are no positive literals, say no <span class="math inline">A_4</span> above, we have <span class="math inline">(A_1 \land A_2 \land A_3) \to \bot</span>.<h2 id="thm.-hornsat">Thm. HORNSAT</h2><blockquote><p><strong>TODO</strong></blockquote><h2 id="to-dos">To-Do’s</h2><ul><li>Define Horn Algorithm and HORNSAT, show it is linear and concludes satisfiablity.<li>Define (with the harder direction) compactness and show propositional logic is compact.<li>Define completeness.<li>Define resolutions and show its completeness.<li>More exercises here.</ul><h1 id="first-order-logic">30. First-Order Logic</h1><p>In this section we will define what we refer to as <strong>first-order logic</strong> which is a much more powerful (in expressive sense) language compared to our previous propositional (zeroth-order) logic. It’s <em>lexicon</em>, who also contains zeroth-order logic defined as<h2 id="def.-alphabet">Def. Alphabet</h2><blockquote><p>Note that if your meta-theory is strong enough in the sense that it allows you to work with classes, say NBG/GB unlike ZFC, you may allow <span class="math inline">\mathbf{S}</span> to be a proper class.</blockquote><p>The <strong>alphabet of a first-order logic</strong> denoted by <span class="math inline">\mathbf{A}_\mathbf{S}</span> is the union of disjoint sets <span class="math inline">\mathbf{A}</span> and <span class="math inline">\mathbf{S}</span> where <span class="math inline">\mathbf{A}</span> is called <strong>the set of (first-order) logical symbols</strong> which is the union of disjoint<ol type="1"><li>(a set of) <strong>variables</strong> <span class="math inline">\{v_0, v_1, v_2 ...\}</span>,<li>(the set of) <strong>connectives</strong> <span class="math inline">\{\neg, \land\}</span>,<li>(the set of) <strong>quantifiers</strong> <span class="math inline">\{\exists\}</span>,<li>the <em>syntactic</em> equality <span class="math inline">\{=\}</span></ol><p>and (possibly empty) set of non-logical symbols <span class="math inline">\mathbf{S}</span> called <strong>the symbol set</strong> (or <strong>vocabulary</strong>) which is the union of disjoint<ol start="6" type="1"><li>(a set of) <strong>constants</strong> <span class="math inline">\{c_0, c_1, c_2, ...\}</span>,<li>(a set of) <span class="math inline">n</span>-ary <strong>relations</strong> <span class="math inline">\{P, Q, R, ...\}</span> for each <span class="math inline">n \geq 1</span>,<li>(a set of) <span class="math inline">n</span>-ary <strong>functions</strong> <span class="math inline">\{f, g, h, ...\}</span> for each <span class="math inline">n \geq 1</span>.</ol><p>Notice that, especially if we consider variables fixed, the set <span class="math inline">\mathbf{A}</span> is independent of <span class="math inline">\mathbf{S}</span> and static in the sense that is the same for all first-order logic alphabets.<h2 id="def.-term">Def. Term</h2><p>Let <span class="math inline">\mathbf{A}_\mathbf{S}</span> be an alphabet of a first-order logic, then the set of <strong>terms</strong> over <span class="math inline">\mathbf{A}_\mathbf{S}</span> denoted with <span class="math inline">\text{Term}(\mathbf{A}_\mathbf{S})</span> is the smallest subset of <span class="math inline">{\mathbf{A}_\mathbf{S}}^*</span> such that<ol type="1"><li>Every variable symbol and constant symbol in <span class="math inline">\mathbf{S}</span> is a term, and<li>For all <span class="math inline">n \geq 1</span>, if <span class="math inline">t_1, ..., t_n</span> are terms, then <span class="math inline">f_n \&gt; t_1 \cdots t_n</span> is also a term where <span class="math inline">f_n \in S</span> is an <span class="math inline">n</span>-ary function symbol.</ol><blockquote><p>Notice that we are working in Polish Notation here. Otherwise, in ordinary infix notation, we also need to add comma and parentheses to our set of non-logical symbols.</blockquote><h2 id="def.-textvart">Def. <span class="math inline">\text{var}(t)</span></h2><p>The <strong>variable</strong> function <span class="math inline">\text{var}</span> is defined on the domain <span class="math inline">\text{Term}(\mathbf{A}_\mathbf{S})</span> inductively as<p><span class="math display">\def\arraystretch{1.25} \begin{array}{rcl} \text{var}(x) &amp;:=&amp; {x} \\ \text{var}(c) &amp;:=&amp; \varnothing \\ \text{var}(f_n \&gt; t_1 \cdots t_n) &amp;:=&amp; \text{var}(t_1) \cup \cdots \cup \text{var}(t_n) \\ \end{array}</span><p>where <span class="math inline">x</span> is a variable symbol, <span class="math inline">c</span> is a constant symbol, and <span class="math inline">t_1, ..., t_n</span> are terms provided to the <span class="math inline">n</span>-ary function symbol <span class="math inline">f_n</span> in <span class="math inline">\mathbf{S}</span>.<h2 id="def.-formula">Def. Formula</h2><p>Let <span class="math inline">\mathbf{A}_\mathbf{S}</span> be an alphabet of a first-order logic, then the set of <strong>formulas</strong> over <span class="math inline">\mathbf{A}_\mathbf{S}</span> denoted with <span class="math inline">\text{Form}(\mathbf{A}_\mathbf{S})</span> is the smallest subset of <span class="math inline">{\mathbf{A}_\mathbf{S}}^*</span> such that, for <span class="math inline">t_1, t_2, ..., t_n \in \text{Term}(\mathbf{A}_\mathbf{S})</span><ol type="1"><li><span class="math inline">t_1 = t_2</span> is a formula,<li><span class="math inline">R_k \&gt; t_1 \&gt; t_2 \cdots t_k</span> is a formula where <span class="math inline">R_k</span> is an <span class="math inline">k</span>-ary relation symbol in <span class="math inline">\mathbf{S}</span>,<li>If <span class="math inline">\varphi \in \text{Form}(\mathbf{A}_\mathbf{S})</span>, then <span class="math inline">\neg \varphi \in \text{Form}(\mathbf{A}_\mathbf{S})</span>,<li>If <span class="math inline">\varphi, \psi \in \text{Form}(\mathbf{A}_\mathbf{S})</span>, then <span class="math inline">\land \&gt; \varphi \&gt; \psi \in \text{Form}(\mathbf{A}_\mathbf{S})</span>,<li>If <span class="math inline">\varphi \in \text{Form}(\mathbf{A}_\mathbf{S})</span>, then <span class="math inline">\exists x \varphi \in \text{Form}(\mathbf{A}_\mathbf{S})</span> where <span class="math inline">x</span> is a variable symbol in <span class="math inline">\mathbf{S}</span>.</ol><p>The formulas which are constructed by (1) or (2) is called <strong>atomic</strong>.<p>From now on we will denote the first-order language we have just defined above with <span class="math inline">\mathcal{L}(\mathbf{A}_\mathbf{S})</span> or simply <span class="math inline">\mathcal{L}(\mathbf{S})</span>. This language, which is a subset of <span class="math inline">{\mathbf{A}_\mathbf{S}}^*</span>, consists of words which we call formulas that are defined inductively.<h2 id="def.-textsubvarphi">Def. <span class="math inline">\text{sub}(\varphi)</span></h2><p>The <strong>subformula</strong> function <span class="math inline">\text{sub}</span> is defined on the domain <span class="math inline">\text{Form}(\mathbf{A}_\mathbf{S})</span> inductively as<p><span class="math display">\def\arraystretch{1.25} \begin{array}{rcl} \text{sub}(t_1 = t_2) &amp;:=&amp; \{t_1 = t_2\} \\ \text{sub}(R_n \&gt; t_1 \cdots t_n) &amp;:=&amp; \{ R_n \&gt; t_1 \cdots t_n \} \\ \text{sub}(\neg \varphi) &amp;:=&amp; \{\neg \varphi \} \cup \text{sub}(\varphi)\\ \text{sub}(\land \&gt; \varphi \&gt; \psi) &amp;:=&amp; \{\land \&gt; \varphi \&gt; \psi\} \cup \text{sub}(\varphi) \cup \text{sub}(\psi) \\ \text{sub}(\exists x \varphi) &amp;:=&amp; \{\exists x \varphi\} \cup \text{sub}(\varphi) \end{array}</span><h2 id="def.-textfreevarphi">Def. <span class="math inline">\text{free}(\varphi)</span></h2><p>The <strong>free variables</strong> function <span class="math inline">\text{free}</span> is defined on the domain <span class="math inline">\text{Form}(\mathbf{A}_\mathbf{S})</span> inductively as<p><span class="math display">\def\arraystretch{1.25} \begin{array}{rcl} \text{free}(t_1 = t_2) &amp;:=&amp; \text{var}(t_1) \cup \text{var}(t_2) \\ \text{free}(R_n \&gt; t_1 \cdots t_n) &amp;:=&amp; \text{var}(t_1) \cup \cdots \cup \text{var}(t_n) \\ \text{free}(\neg \varphi) &amp;:=&amp; \text{free}(\varphi) \\ \text{free}(\land \&gt; \varphi \&gt; \psi) &amp;:=&amp; \text{free}(\varphi) \cup \text{free}(\psi) \\ \text{free}(\exists x \varphi) &amp;:=&amp; \text{free}(\varphi) \setminus \{x\} \end{array}</span><h2 id="notation.-first-order-logic">Notation. First-Order Logic</h2><p>Let <span class="math inline">\varphi \in \mathcal{L}(\mathbf{S})</span>, then we define — in addition to its <span class="math inline">\lor</span>, <span class="math inline">\to</span>, <span class="math inline">\leftrightarrow</span> counterparts in propositional logic<ul><li><span class="math inline">\forall x \varphi := \neg \exists x \neg \varphi</span> where <span class="math inline">x</span> is a variable symbol in <span class="math inline">\mathbf{S}</span></ul><h2 id="def.-textfreevarphi-1">Def. <span class="math inline">\text{free}(\varphi)</span></h2><p>The <strong>free variable</strong> function <span class="math inline">\text{free}</span> is defined on the language <span class="math inline">\mathcal{L}(\mathbf{S})</span> inductively as<p><span class="math display">\def\arraystretch{1.25} \begin{array}{rcl} \text{free}(t_1 = t_2) &amp;:=&amp; \text{var}(t_1) \cup \text{var}(t_2) \\ \text{free}(R_n \&gt; t_1 \cdots t_n) &amp;:=&amp; \text{var}(t_1) \cup \cdots \cup \text{var}(t_n) \\ \text{free}(\neg \varphi) &amp;:=&amp; \text{free}(\varphi) \\ \text{free}(\land \&gt; \varphi \&gt; \psi) &amp;:=&amp; \text{free}(\varphi) \cup \text{free}(\psi) \\ \text{free}(\exists x \varphi) &amp;:=&amp; \text{free}(\varphi) \setminus \{x\} \end{array}</span><p>where <span class="math inline">x</span> is a variable symbol, <span class="math inline">t_1, ..., t_n</span> are terms, <span class="math inline">R_n</span> is an <span class="math inline">n</span>-ary relation symbol, and <span class="math inline">\varphi</span> and <span class="math inline">\psi</span> are formulas in <span class="math inline">\mathcal{L}(\mathbf{S})</span>.<p>A variable which is not free is called <strong>bound</strong>.<h2 id="def.-sentence">Def. Sentence</h2><p>A <strong>sentence</strong> in a first-order logic is a formula without free variables.<h2 id="to-dos-1">To-Do’s</h2><ul><li>Variables, free and bound variables<li>Well-formedness<li>Structures<li>Abstract Syntax Trees and Polish Notation<li>NAND Representations</ul><h1 id="structures">40. Structures</h1><h2 id="def.-structure">Def. Structure</h2><p>Let <span class="math inline">\mathbf{S}</span> be a symbol set, then a <strong>structure</strong> of <span class="math inline">\mathbf{S}</span> is a tuple <span class="math inline">\mathfrak{S} = (\mathbf{V}, \mathbf{v})</span> such that<ol type="1"><li><span class="math inline">\mathbf{V}</span> is a non-empty set called the <strong>universe</strong> (or <strong>domain</strong>) of <span class="math inline">\mathfrak{S}</span>.<li><span class="math inline">\mathbf{v}</span> is a map defined on <span class="math inline">\mathbf{S}</span> such that<ol type="1"><li><span class="math inline">\mathbf{v}(R)</span> is an <span class="math inline">n</span>-ary relation on <span class="math inline">\mathbf{V}</span> for all <span class="math inline">n</span>-ary relation symbol in <span class="math inline">\mathbf{S}</span>.<li><span class="math inline">\mathbf{v}(f)</span> is an <span class="math inline">n</span>-ary function on <span class="math inline">\mathbf{V}</span> for all <span class="math inline">n</span>-ary function symbol in <span class="math inline">\mathbf{S}</span>.<li><span class="math inline">\mathbf{v}(c)</span> is an element of <span class="math inline">\mathbf{V}</span> for all constant symbols in <span class="math inline">\mathbf{S}</span>.</ol></ol><h2 id="def.-valuation-1">Def. Valuation</h2><p>A <strong>valuation</strong> <span class="math inline">\mathfrak{v}</span> in a structure <span class="math inline">\mathfrak{S} = (\mathbf{V}, \mathbf{v})</span> is a map such that<p><span class="math display">\mathfrak{v}: \Set{v_n}_{n \&gt; \in \&gt; \N} \to \mathbf{V}</span><p>where <span class="math inline">\Set{v_n}_{n \&gt; \in \&gt; \N}</span> is the set of variable symbols in <span class="math inline">\mathbf{A}_\mathbf{S}</span> and <span class="math inline">\mathbf{V}</span> is the universe.<p>Moreover, we also define, for <strong>substitution</strong><p><span class="math display">\mathfrak{v} \dfrac{y}{x} (v) := \begin{cases} \&gt; \mathfrak{v}(v) &amp;\text{if } &amp; v \neq x \\ \&gt; y &amp;\text{if } &amp; v = x \end{cases}</span><h2 id="def.-interpretation">Def. Interpretation</h2><p>An <strong>interpretation</strong> or <strong>model</strong> <span class="math inline">\mathfrak{M}</span> is a tuple <span class="math inline">(\mathfrak{S}, \mathfrak{v})</span> where <span class="math inline">\mathfrak{S}</span> is a structure and <span class="math inline">\mathfrak{v}</span> is a valuation in <span class="math inline">\mathfrak{S}</span>.<h2 id="notation.-model">Notation. Model</h2><p>Let <span class="math inline">\mathfrak{M} = (\mathfrak{S}, \mathfrak{v})</span> be a model such that <span class="math inline">\mathfrak{S} = (\mathbf{V}, \mathbf{v})</span>. We define<p><span class="math display">\def\arraystretch{1.5} \begin{array}{rcl} \mathfrak{M}\dfrac{y}{x} &amp;:=&amp; (\mathfrak{S}, \mathfrak{v} \dfrac{y}{x} )&amp; \\ \\ \mathfrak{M}(x) &amp;:=&amp; \mathfrak{v}(x) \\ \mathfrak{M}(c) &amp;:=&amp; \mathbf{v}(c) \\ \mathfrak{M}(f \&gt; t_1 \&gt; t_2 \cdots t_n) &amp;:=&amp; \mathbf{v}(f)(\mathfrak{M}(t_1), \mathfrak{M}(t_2), ..., \mathfrak{M}(t_n)) \\ \end{array}</span><p>where <span class="math inline">x</span> is a variable, <span class="math inline">c</span> is a constant, <span class="math inline">f</span> is an <span class="math inline">n</span>-ary function symbol, and <span class="math inline">t_1, ..., t_n</span> are terms.<p>Moreover, similar to propositional logic, we define<p><span class="math display">\begin{array}{lcl} \mathfrak{M} \models t_1 = t_2 &amp; \text{iff} &amp; \mathfrak{M}(t_1) = \mathfrak{M}(t_2) \\ \mathfrak{M} \models \neg \varphi &amp; \text{iff} &amp; \text{not} \enspace \mathfrak{M} \models \varphi \\ \mathfrak{M} \models \varphi \land \psi &amp; \text{iff} &amp; \mathfrak{M} \models \varphi \enspace \text{and} \enspace \mathfrak{M} \models \psi \\ \mathfrak{M} \models \exists x \varphi &amp; \text{iff} &amp; \mathfrak{M} \dfrac{a}{x} \models \varphi \enspace \text{for some} \enspace a \in \mathbf{V}\\ \mathfrak{M} \models R \&gt; t_1 \cdots t_n &amp; \text{iff} &amp; (\mathfrak{M}(t_1), ..., \mathfrak{M}(t_n)) \in \mathbf{v}(R) \end{array}</span><p>Similar to propositiona logic, if <span class="math inline">\Delta</span> is a set of first-order formulas, then <span class="math inline">\mathfrak{M} \models \Delta</span> denotes that <span class="math inline">\mathfrak{M} \models \varphi</span> for all <span class="math inline">\varphi \in \Delta</span>.<h2 id="def.-entails-1">Def. Entails</h2><p>Let <span class="math inline">\Delta</span> be a set of formulas and <span class="math inline">\varphi</span> a formula, then we say <span class="math inline">\Delta</span> <strong>entails</strong> <span class="math inline">\varphi</span> or <span class="math inline">\varphi</span> is a <strong>consequence</strong> of <span class="math inline">\Delta</span> denoted <span class="math inline">\Delta \models \varphi</span> if for every model <span class="math inline">\mathfrak{M}</span> such that <span class="math inline">\mathfrak{M} \models \Delta</span>, we have <span class="math inline">\mathfrak{M} \models \varphi</span>.<p>If <span class="math inline">\Delta = \{\psi\}</span>, then we simply write <span class="math inline">\psi \models \varphi</span> instead of <span class="math inline">\{\psi\} \models \varphi</span>.<p>Moreover, if two formulas <span class="math inline">\varphi</span> and <span class="math inline">\psi</span> entail each other denoted <span class="math inline">\varphi \equiv \psi</span> we say they are <strong>(logically) equivalent</strong>.<h2 id="def.-valid">Def. Valid</h2><p>We say a formula <span class="math inline">\varphi</span> is a <strong>tautology</strong> (or <strong>valid</strong>) denoted <span class="math inline">\models \varphi</span> if <span class="math inline">\varnothing \models \varphi</span>. So that <span class="math inline">\varphi</span> holds under any model.<h2 id="def.-satisfiable">Def. Satisfiable</h2><p>We say a set of formulas <span class="math inline">\Delta</span> is <strong>satisfiable</strong> denoted <span class="math inline">\text{Sat }\Delta</span> if there exists a model <span class="math inline">\mathfrak{M}</span> such that <span class="math inline">\mathfrak{M} \models \Delta</span>.</div>